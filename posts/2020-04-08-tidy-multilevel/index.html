<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2020-04-08">
<meta name="description" content="This is the narrative lesson plan and tutorial for my 2-hour R workshop, Wrangling Multilevel Data in the R Tidyverse. Come on in!">

<title>Wrangling multilevel data in the tidyverse – Monica Thieu, PhD</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-1cda4e04c498cf0b7e501f8abc9db53a.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Monica Thieu, PhD</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../posts.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://cocoa-lab-usd.netlify.app"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-teaching" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Teaching</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-teaching">    
        <li>
    <a class="dropdown-item" href="../../teaching/teaching-statement.html">
 <span class="dropdown-text">Teaching philosophy</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../teaching/teaching-roles.html">
 <span class="dropdown-text">Teaching roles and responsibilities</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../teaching/teaching-impact.html">
 <span class="dropdown-text">Teaching impact</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../teaching/teaching-materials.html">
 <span class="dropdown-text">Example teaching materials</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../game-shows.html"> 
<span class="menu-text">Game shows</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../contact.html"> 
<span class="menu-text">Contact</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#learning-goals" id="toc-learning-goals" class="nav-link active" data-scroll-target="#learning-goals">Learning goals</a></li>
  <li><a href="#notes-for-instructors" id="toc-notes-for-instructors" class="nav-link" data-scroll-target="#notes-for-instructors">Notes for instructors</a></li>
  <li><a href="#lesson-body" id="toc-lesson-body" class="nav-link" data-scroll-target="#lesson-body">Lesson body</a>
  <ul class="collapse">
  <li><a href="#a-brief-intro-to-multilevel-structure-its-everywhere" id="toc-a-brief-intro-to-multilevel-structure-its-everywhere" class="nav-link" data-scroll-target="#a-brief-intro-to-multilevel-structure-its-everywhere">A brief intro to multilevel structure: It’s everywhere!</a></li>
  <li><a href="#introducing-the-data" id="toc-introducing-the-data" class="nav-link" data-scroll-target="#introducing-the-data">Introducing the data</a></li>
  <li><a href="#reading-in-the-data" id="toc-reading-in-the-data" class="nav-link" data-scroll-target="#reading-in-the-data">Reading in the data</a></li>
  <li><a href="#inspecting-the-data" id="toc-inspecting-the-data" class="nav-link" data-scroll-target="#inspecting-the-data">Inspecting the data</a>
  <ul class="collapse">
  <li><a href="#quick-graphs" id="toc-quick-graphs" class="nav-link" data-scroll-target="#quick-graphs">Quick graphs</a></li>
  <li><a href="#basic-summary-statistics" id="toc-basic-summary-statistics" class="nav-link" data-scroll-target="#basic-summary-statistics">Basic summary statistics</a></li>
  </ul></li>
  <li><a href="#nesting-the-data" id="toc-nesting-the-data" class="nav-link" data-scroll-target="#nesting-the-data">Nesting the data</a>
  <ul class="collapse">
  <li><a href="#intro-to-nest-unnest-and-tibble-list-columns" id="toc-intro-to-nest-unnest-and-tibble-list-columns" class="nav-link" data-scroll-target="#intro-to-nest-unnest-and-tibble-list-columns">Intro to nest(), unnest(), and tibble list-columns</a></li>
  </ul></li>
  <li><a href="#going-vectorize-crazy" id="toc-going-vectorize-crazy" class="nav-link" data-scroll-target="#going-vectorize-crazy">Going vectorize crazy</a>
  <ul class="collapse">
  <li><a href="#vectorizing-its-like-a-for-loop-but-not" id="toc-vectorizing-its-like-a-for-loop-but-not" class="nav-link" data-scroll-target="#vectorizing-its-like-a-for-loop-but-not">Vectorizing: it’s like a for loop, but not</a></li>
  <li><a href="#tidy-vectorizing" id="toc-tidy-vectorizing" class="nav-link" data-scroll-target="#tidy-vectorizing">Tidy vectorizing</a></li>
  <li><a href="#a-caveat-when-not-to-vectorize" id="toc-a-caveat-when-not-to-vectorize" class="nav-link" data-scroll-target="#a-caveat-when-not-to-vectorize">A caveat: When not to vectorize</a></li>
  </ul></li>
  <li><a href="#hella-models" id="toc-hella-models" class="nav-link" data-scroll-target="#hella-models">Hella models</a>
  <ul class="collapse">
  <li><a href="#fitting-many-models" id="toc-fitting-many-models" class="nav-link" data-scroll-target="#fitting-many-models">Fitting many models</a></li>
  <li><a href="#extracting-statistics-from-models" id="toc-extracting-statistics-from-models" class="nav-link" data-scroll-target="#extracting-statistics-from-models">Extracting statistics from models</a></li>
  <li><a href="#visualizing-many-statistics" id="toc-visualizing-many-statistics" class="nav-link" data-scroll-target="#visualizing-many-statistics">Visualizing many statistics</a></li>
  </ul></li>
  <li><a href="#bonus-example-bootstrapping" id="toc-bonus-example-bootstrapping" class="nav-link" data-scroll-target="#bonus-example-bootstrapping">Bonus example: bootstrapping</a></li>
  </ul></li>
  <li><a href="#in-closing" id="toc-in-closing" class="nav-link" data-scroll-target="#in-closing">In closing</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Wrangling multilevel data in the tidyverse</h1>
  <div class="quarto-categories">
    <div class="quarto-category">R</div>
    <div class="quarto-category">tidyverse</div>
    <div class="quarto-category">tutorial</div>
  </div>
  </div>

<div>
  <div class="description">
    This is the narrative lesson plan and tutorial for my 2-hour R workshop, <strong>Wrangling Multilevel Data in the R Tidyverse.</strong> Come on in!
  </div>
</div>


<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">April 8, 2020</p>
    </div>
  </div>
  
    <div>
    <div class="quarto-title-meta-heading">Modified</div>
    <div class="quarto-title-meta-contents">
      <p class="date-modified">December 31, 2024</p>
    </div>
  </div>
    
  </div>
  


</header>


<p>This is the narrative lesson plan for my 2-hour R workshop, <strong>Wrangling Multilevel Data in the R Tidyverse.</strong></p>
<blockquote class="blockquote">
<p>The code examples have been updated with the following:</p>
<ul>
<li><code>\(x)</code> anonymous function shorthand now recommended inside <code>map()</code>, according to purrr &gt;= 1.0.0 and R &gt;= 4.0 style</li>
<li><code>geom_pointrange()</code> is now used to plot points and error bars together, instead of <code>geom_errorbar() + geom_point()</code>. I like <code>geom_pointrange()</code> better now for conciseness!</li>
</ul>
</blockquote>
<section id="learning-goals" class="level1">
<h1>Learning goals</h1>
<p>By the end of this lesson, learners will be able to:</p>
<ul>
<li>“fold” and “unfold” tibble list-columns with <code>tidyr::nest()</code>/<code>unnest()</code></li>
<li>use <code>purrr::map()</code> to flexibly perform vectorized operations on nested data</li>
<li>more specifically, fit a single model to each subset of a multilevel dataset</li>
<li>visualize subset-model summary statistics all together with <code>ggplot2</code></li>
</ul>
<p>Learners will also review the following skills:</p>
<ul>
<li>reading in tabular data with <code>readr</code></li>
<li>using the pipe <code>%&gt;%</code> to construct human-readable chains of functions</li>
<li>inspecting data and diagnosing any necessary data cleaning</li>
<li>calculating summary statistics on observation-level data with <code>group_by()</code> and <code>summarize()</code></li>
<li>Fit a multiple regression using <code>lm()</code> and interpret coefficient values</li>
<li>generalizing statistical techniques to data collected on different topics</li>
</ul>
<p>This tutorial is not written as an exhaustive walkthrough of <em>all</em> of the use cases and capabilities of these functions/packages. Rather, it is written as a bite-size tour of an example data analysis from start to finish*.</p>
<p>For more exhaustive documentation, you can visit the online reference pages for your package of interest. For more in-depth self-teaching, please refer to the <a href="http://r4ds.had.co.nz/">R for Data Science online textbook</a> by Garrett Grolemund and Hadley Wickham.</p>
<p>*The analyses demonstrated here are by no means the final analyses you might do with these data! There is just only so much that can be covered within the scope of this tutorial.</p>
</section>
<section id="notes-for-instructors" class="level1">
<h1>Notes for instructors</h1>
<p>This lesson is written to be usable as a standalone, follow-along-at-home tutorial. For those wishing to use this as a lesson plan for live instruction, please refer to the following.</p>
<ul>
<li><strong>Do not copy and paste code from the lesson document into console/your live-coding document.</strong> Please feel free to follow the code line by line with the lesson. However, I consider it critical for you to <em>live-code every piece of code you can;</em> that is, type <em>everything</em> out by hand and narrate, piece by piece, out loud as you do so. This has two main benefits:
<ul>
<li>Requires you, the instructor, to digest and explain each piece of code you type</li>
<li>Paces your typing so that learners can keep up as they type along with you</li>
</ul></li>
<li><strong>Do ad-lib on the plain-text lecture notes.</strong> What I have is not exhaustive. If you want to spend more or less time explaining something than I’ve allotted, it’s your call.</li>
</ul>
<p>I have some useful asides written throughout the tutorial marked as <strong>instructor’s notes.</strong> If you’re following along with this tutorial at home, you may find these notes useful as supplementary information. Usually, these notes will occur in locations where I have deliberately <em>omitted</em> teaching a particular concept or technique. I’ve tried to summarize what I’m omitting from the primary lesson plan and why I’m doing so, with links for additional exploration for those at home who do want to jump further in.</p>
<p>And now, the feature presentation:</p>
</section>
<section id="lesson-body" class="level1">
<h1>Lesson body</h1>
<section id="a-brief-intro-to-multilevel-structure-its-everywhere" class="level2">
<h2 class="anchored" data-anchor-id="a-brief-intro-to-multilevel-structure-its-everywhere">A brief intro to multilevel structure: It’s everywhere!</h2>
<p>Chances are, you’ve dealt with multilevel data before.</p>
<p>In the more micro-scale experimental sciences, data take multilevel structure every time you take multiple measurements per research unit, repeated for multiple research units. In psychology research like mine, this means multiple measurements per participant, repeated for multiple participants. This holds true for any set of multiple measurements out of multiple lab setups (petri dishes, vacuum chambers, whatever you use). Observations can be <em>grouped</em> in all of these cases, by whichever participant/lab apparatus/otherwise that they were collected from.</p>
<p>In the macro-scale observational (and more often social) sciences, you might have multiple measurements per city, state, or country, repeated for multiple cities/states/countries. Again, this yields data that can be grouped by the locale from which they were collected.</p>
<p>And in any research, if you have a collaborative project across multiple labs where each lab is collecting the same data at their home location, the data now have multilevel structure because they can be grouped by the lab at which they were collected.</p>
<p>When you have multiple measurements per group, across many grouping units, you have <strong>multilevel data!</strong> It’s important when you do have multilevel data to characterize patterns in the data both <em>within</em> and <em>between units.</em> This is important to do for deep statistical reasons, but for today, these reasons can be summarized by the following:</p>
<p><em>In general, any two observations from the same units are more likely to have something in common with one another than any two observations from different units.</em> We thus benefit from accounting for the fact that variance within a unit is not equivalent to variance between units.</p>
<p>Here’s an extreme example of cases where the within-unit and between-unit patterns are actively at odds with one another:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/example-multilevel-data-plot-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>If you had data that took this structure, where the slope within units was positive, but the overall values between units are scattered in such a way that the slope across units was negative, failing to examine the unit-level relationships before jumping into the overall data analysis might lead you to draw erroneous conclusions!</p>
<p>More generally, a particular relationship that holds within the observations of a single unit might look different in another unit, and eyeballing the possible similarities/differences in these relationships is the first step to accounting for them statistically in the future. <strong>In this tutorial, we’ll be practicing using tidyverse techniques to do this eyeballing cleanly and efficiently.</strong></p>
<p>The content of this tutorial is technically not statistical in nature, but the motivation behind it is inherently statistical, so that’s why I want to take the time to introduce the statistical reasoning, at least conceptually, before we jump into the R.</p>
<p>And importantly, the techniques we practice today are useful for <em>any</em> data analysis you want to repeat over many identically-structured sub-datasets. I’ll demonstrate another one of these applications, bootstrap resampling analysis, at <a href="#bonus-example-bootstrapping">the end of this tutorial</a>.</p>
<blockquote class="blockquote">
<p><strong>Instructor’s note:</strong> A full exploration of the motivations behind multilevel data analysis is beyond the scope of this tutorial. Today, we will be focusing on data wrangling tools you can use to explore the multilevel-ness of your data, which can lend useful insights no matter how you ultimately decide to analyze your data.</p>
</blockquote>
</section>
<section id="introducing-the-data" class="level2">
<h2 class="anchored" data-anchor-id="introducing-the-data">Introducing the data</h2>
<p>In this tutorial, we’ll be exploring grocery store sales data of millenials’ favorite fruit: avocados!</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/25/Avocado_open_side_by_side.jpg/640px-Avocado_open_side_by_side.jpg" class="img-fluid figure-img"></p>
<figcaption>The fruit that launched a thousand guacamoles?</figcaption>
</figure>
</div>
<p><a href="https://www.kaggle.com/neuromusic/avocado-prices/data">These data</a> originally come from the Hass Avocado board, via Justin Kiggins on Kaggle. (I downloaded the local copy of these data on 2020-03-25.)</p>
<p>The data come from many weekly measures of avocado sales over a few years, collected in many metropolitan areas of the United States. Intuitively, we might expect that avocado sale data might differ based on which region the avocados were sold in. For example, all regions of the US might show similar patterns of avocado sales, but at different levels depending on the average cost of living in that region. Avocados probably sell for cheaper in Dallas, TX, where I grew up, than in New York City, where I live currently, and I’d like to group avocado sales by region so that region-specific avocado prices don’t influence the patterns I see in the data.</p>
<hr>
<p>A brief note:</p>
<p>Unless you specifically do research on grocery store avocado prices, it’s unlikely that these data map directly onto the data you deal with in your own research, and <em>that’s okay.</em> It’s important to practice abstracting data cleaning/manipulation and statistical techniques <em>away from the specific data you’re practicing them on,</em> so that you can learn from techniques demonstrated in other disciplines, figure out how they might help you with your own data, and then apply those techniques. Psychologists can learn from economists can learn from biologists, and vice versa. :)</p>
<hr>
</section>
<section id="reading-in-the-data" class="level2">
<h2 class="anchored" data-anchor-id="reading-in-the-data">Reading in the data</h2>
<p>This blog post’s local copy of the avocado sales CSV can be found in the static website files <a href="avocado.csv">here</a>. You should be able to download the CSV from that link by right-clicking and downloading a copy to your computer, or if your computer is actively connected to the internet, you can use the URL as the path to data in a <code>readr::read_csv()</code> call.</p>
<p>In this post, I can use a relative path because the .Rmd this web page is generated from is saved in the same folder as the avocado data. You will need to use the appropriate URL or path to a local copy of the data when you <code>read_csv()</code> on your own machine, so be aware that copying and pasting the code out of this chunk will probably not work out of the box.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>avocado_raw <span class="ot">&lt;-</span> <span class="fu">read_csv</span>(<span class="st">"avocado.csv"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># When I want to rename columns, I try to leave the raw data UNTOUCHED</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># to improve reproducibility in case someone else were to download the data</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># directly from the source I did</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># as such, all renaming is done on the tibble after I've read it into R</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rename</span>(<span class="at">row_num =</span> <span class="st">"...1"</span>,</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>         <span class="at">date =</span> <span class="st">"Date"</span>,</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>         <span class="at">avg_price =</span> <span class="st">"AveragePrice"</span>,</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>         <span class="at">total_volume =</span> <span class="st">"Total Volume"</span>,</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>         <span class="at">PLU4046_sold =</span> <span class="st">"4046"</span>,</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>         <span class="at">PLU4225_sold =</span> <span class="st">"4225"</span>,</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>         <span class="at">PLU4770_sold =</span> <span class="st">"4770"</span>,</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>         <span class="at">total_bags =</span> <span class="st">"Total Bags"</span>,</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>         <span class="at">small_bags =</span> <span class="st">"Small Bags"</span>,</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>         <span class="at">large_bags =</span> <span class="st">"Large Bags"</span>,</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>         <span class="at">xlarge_bags =</span> <span class="st">"XLarge Bags"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  <span class="co"># There's a row numbers column written out in the raw csv.</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  <span class="co"># I don't think we need this so I'll select that column out</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(<span class="sc">-</span>row_num) <span class="sc">%&gt;%</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>  <span class="co"># For efficiency, I'll store the year as integer</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">year =</span> lubridate<span class="sc">::</span><span class="fu">year</span>(date) <span class="sc">%&gt;%</span> <span class="fu">as.integer</span>())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s take a peek at the first few rows of the data.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>avocado_raw</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 18,249 × 13
   date       avg_price total_volume PLU4046_sold PLU4225_sold PLU4770_sold
   &lt;date&gt;         &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;
 1 2015-12-27      1.33       64237.        1037.       54455.         48.2
 2 2015-12-20      1.35       54877.         674.       44639.         58.3
 3 2015-12-13      0.93      118220.         795.      109150.        130. 
 4 2015-12-06      1.08       78992.        1132        71976.         72.6
 5 2015-11-29      1.28       51040.         941.       43838.         75.8
 6 2015-11-22      1.26       55980.        1184.       48068.         43.6
 7 2015-11-15      0.99       83454.        1369.       73673.         93.3
 8 2015-11-08      0.98      109428.         704.      101815.         80  
 9 2015-11-01      1.02       99811.        1022.       87316.         85.3
10 2015-10-25      1.07       74339.         842.       64757.        113  
# ℹ 18,239 more rows
# ℹ 7 more variables: total_bags &lt;dbl&gt;, small_bags &lt;dbl&gt;, large_bags &lt;dbl&gt;,
#   xlarge_bags &lt;dbl&gt;, type &lt;chr&gt;, year &lt;int&gt;, region &lt;chr&gt;</code></pre>
</div>
</div>
<p>We can get a partial codebook of what data these columns contain from Justin Kiggins, the uploader of the original Kaggle dataset:</p>
<blockquote class="blockquote">
<p>Some relevant columns in the dataset:</p>
<ul>
<li><code>date</code> - The date of the observation</li>
<li><code>avg_price</code> - the average price of a single avocado</li>
<li><code>type</code> - conventional or organic</li>
<li><code>year</code> - the year</li>
<li><code>region</code> - the city or region of the observation</li>
<li><code>total_volume</code> - Total number of avocados sold</li>
<li><code>PLUXXXX_sold</code> - Total number of avocados with PLU XXXX sold</li>
</ul>
</blockquote>
<p>Finally, we can assume that the <code>*_bags</code> columns measure the total number of variously sized bags of avocados in a given week.</p>
<p>Going forward, we’ll treat <code>region</code> as the unit grouping variable. What all regions are there?</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">unique</span>(avocado_raw<span class="sc">$</span>region)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] "Albany"              "Atlanta"             "BaltimoreWashington"
 [4] "Boise"               "Boston"              "BuffaloRochester"   
 [7] "California"          "Charlotte"           "Chicago"            
[10] "CincinnatiDayton"    "Columbus"            "DallasFtWorth"      
[13] "Denver"              "Detroit"             "GrandRapids"        
[16] "GreatLakes"          "HarrisburgScranton"  "HartfordSpringfield"
[19] "Houston"             "Indianapolis"        "Jacksonville"       
[22] "LasVegas"            "LosAngeles"          "Louisville"         
[25] "MiamiFtLauderdale"   "Midsouth"            "Nashville"          
[28] "NewOrleansMobile"    "NewYork"             "Northeast"          
[31] "NorthernNewEngland"  "Orlando"             "Philadelphia"       
[34] "PhoenixTucson"       "Pittsburgh"          "Plains"             
[37] "Portland"            "RaleighGreensboro"   "RichmondNorfolk"    
[40] "Roanoke"             "Sacramento"          "SanDiego"           
[43] "SanFrancisco"        "Seattle"             "SouthCarolina"      
[46] "SouthCentral"        "Southeast"           "Spokane"            
[49] "StLouis"             "Syracuse"            "Tampa"              
[52] "TotalUS"             "West"                "WestTexNewMexico"   </code></pre>
</div>
</div>
<p>Most of these regions appear to correspond to specific metropolitan areas. However, I do see some regions in this data that look like supersets of other regions. <code>"TotalUS"</code> ought to be a superset of all of the individual metropolitan regions, and, for example, <code>"California"</code> should encompass <code>c("LosAngeles", "Sacramento", "SanDiego", "SanFrancisco")</code>. I’m going to go ahead and <code>filter()</code> out all the data that are for multi-metropolitan regions so we can do our best to avoid double-counting.</p>
<p>I’m also going to <code>select()</code> out the <code>*_bags</code> columns and the <code>PLU*_sold</code> columns, as I don’t plan to be doing any stats on the numbers of variously sized avocado bags sold per week, or avocado sales by avocado size (the different PLU values correspond to small, large, and extra large avocados). I think we can get most of the useful information in this data from the remaining columns.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Note that I'm not removing GreatLakes, NorthernNewEngland, or WestTexNewMexico</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co"># because I think those are counting large regions that don't have a big city</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co"># so they're not double-counting the other cities</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>avocado <span class="ot">&lt;-</span> avocado_raw <span class="sc">%&gt;%</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(<span class="sc">!</span>(region <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"California"</span>,</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>                         <span class="st">"Midsouth"</span>,</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>                         <span class="st">"Northeast"</span>,</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>                         <span class="st">"Plains"</span>,</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>                         <span class="st">"SouthCentral"</span>,</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>                         <span class="st">"Southeast"</span>,</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>                         <span class="st">"TotalUS"</span>,</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>                         <span class="st">"West"</span>))) <span class="sc">%&gt;%</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(<span class="sc">-</span><span class="fu">ends_with</span>(<span class="st">"bags"</span>), <span class="sc">-</span><span class="fu">starts_with</span>(<span class="st">"PLU"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>A latent benefit of removing unwanted columns in the data is that when we print the tibble to console to inspect the first several rows, we can see more columns that were originally pushed off to the side.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>avocado</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 15,545 × 6
   date       avg_price total_volume type          year region
   &lt;date&gt;         &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt;        &lt;int&gt; &lt;chr&gt; 
 1 2015-12-27      1.33       64237. conventional  2015 Albany
 2 2015-12-20      1.35       54877. conventional  2015 Albany
 3 2015-12-13      0.93      118220. conventional  2015 Albany
 4 2015-12-06      1.08       78992. conventional  2015 Albany
 5 2015-11-29      1.28       51040. conventional  2015 Albany
 6 2015-11-22      1.26       55980. conventional  2015 Albany
 7 2015-11-15      0.99       83454. conventional  2015 Albany
 8 2015-11-08      0.98      109428. conventional  2015 Albany
 9 2015-11-01      1.02       99811. conventional  2015 Albany
10 2015-10-25      1.07       74339. conventional  2015 Albany
# ℹ 15,535 more rows</code></pre>
</div>
</div>
<blockquote class="blockquote">
<p><strong>Instructor’s note:</strong> If you wish, you can set tibble printing options to print preview values for all columns of a tibble, irrespective of whether those additional columns spill over to the next row of print output. You can do it temporarily by explicitly calling <code>print(my_tibble, width = Inf)</code> to override the default console-width-detecting behavior, or by setting your R instance’s global options with <code>options(tibble.width = Inf)</code> to print all columns for all tibbles. However, I personally like the width-restricting behavior of default tibble printing. I’ll take the clean console output.</p>
</blockquote>
</section>
<section id="inspecting-the-data" class="level2">
<h2 class="anchored" data-anchor-id="inspecting-the-data">Inspecting the data</h2>
<p>Today’s explorations will focus around the following diffuse research question: <strong>Do avocado buyers prefer buying conventional or organic avocados? By how much? How do these patterns differ from region to region?</strong> For a variety of reasons (pick your favorite), it might be interesting to try to quantify grocery shoppers’ relative preference for conventional vs.&nbsp;organic avocados, as it probably tracks with regional variations in supply chain access, and/or psychological attitudes about health and environmentalism.</p>
<p>(We won’t be able to get into those more complex variables because they aren’t present in the avocado data we have, but just an inspiration!)</p>
<p>Even before we get into looking for more complex statistics within each region, we can use simpler tidyverse tools to generate and inspect single-value summary statistics, both visually and numerically, for each metropolitan area present in the data.</p>
<section id="quick-graphs" class="level3">
<h3 class="anchored" data-anchor-id="quick-graphs">Quick graphs</h3>
<p>We can use built-in grouping features of <code>ggplot2</code> to inspect the data visually without having to pre-manipulate it much.</p>
<p>First, let’s look at a histogram of weekly avocado sales, across all weeks, and all metropolitan areas. How many avocados are people buying in a given week? I’m also going to split this histogram to get two different filled histograms for conventional and organic avocado sales so we can see those sales separately. I’ll set the colors to… ah, avocado-themed.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>avo_colors <span class="ot">=</span> <span class="fu">c</span>(<span class="st">"sienna4"</span>, <span class="st">"olivedrab2"</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>plot_hist_avo_total_volume <span class="ot">&lt;-</span> avocado <span class="sc">%&gt;%</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> total_volume, <span class="at">fill =</span> type)) <span class="sc">+</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_histogram</span>(<span class="at">position =</span> <span class="st">"identity"</span>, <span class="at">bins =</span> <span class="dv">25</span>, <span class="at">alpha =</span> <span class="fl">0.5</span>) <span class="sc">+</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_fill_manual</span>(<span class="at">values =</span> avo_colors) <span class="sc">+</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>plot_hist_avo_total_volume</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/avo-vol-hist-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Ooh, yikes, the weekly total avocados sold looks super gamma-skewed. Most weeks it’s maybe a few tens of thousands of avocados sold, but in some weeks and some regions it gets into the millions of avocados sold (that’s a lot of avocados in a week!), so we would probably do well to log-transform the data to try to get it to take a more normal-ish distribution.</p>
<p>Right now, we can use one of <code>ggplot2</code>’s scale helper functions to set the scale to be on log-10 units.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>plot_hist_avo_total_volume <span class="sc">+</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_x_log10</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/avo-vol-hist-scaled-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>That looks much better! Now we can proceed.</p>
<p>Next, let’s break up the graph by region, so we can see the sub-histograms of total avocados sold for each metropolitan area. A super-fast way to break up your graph by each grouping unit is to <em>facet</em> your ggplot, or to break it up into small multiples. I like to use <code>facet_wrap(~ grouping_unit)</code> to break a single plot up, so that the data for each metro area is displayed on its own sub-plot, or facet. The “wrap” part of <code>facet_wrap()</code> tries to arrange the facets in “reading” order, from left-to-right and then top-to-bottom to fill the plot area as efficiently as possible.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>plot_hist_avo_total_volume <span class="sc">+</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># let's not forget to log-scale the x-axis!</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_x_log10</span>() <span class="sc">+</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_wrap</span>(<span class="sc">~</span> region)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/avo-vol-hist-faceted-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Incidentally, graphing data at first can be a great way of identifying important variables in the data that need to be considered. For example, what if I had forgotten to break up the sales data by conventional vs.&nbsp;organic avocado type?</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>avocado <span class="sc">%&gt;%</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Notice that I've removed the fill aesthetic</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># so now it's not splitting by avo type</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> total_volume)) <span class="sc">+</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_histogram</span>(<span class="at">position =</span> <span class="st">"identity"</span>, <span class="at">bins =</span> <span class="dv">25</span>, <span class="at">alpha =</span> <span class="fl">0.5</span>) <span class="sc">+</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_x_log10</span>() <span class="sc">+</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/avo-vol-hist-bad-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>I might see a bimodal histogram and say “huh, that’s funny.” If I weren’t so careful, I might continue my business without accounting for this bimodality. But optimally I’d stop and think “what additional variable might be driving this bimodality?” and after some exploration, realize that I need to consider conventional vs.&nbsp;organic avocado type when looking at avocado sales in order to properly characterize the data. Always keep an eye out!</p>
</section>
<section id="basic-summary-statistics" class="level3">
<h3 class="anchored" data-anchor-id="basic-summary-statistics">Basic summary statistics</h3>
<p>In addition to graphs, we can generate simple one-shot summary statistics using <code>group_by()</code> and <code>summarize()</code> from the <code>dplyr</code> package.</p>
<p>As a companion to the exploratory graphs of <code>total_volume</code> we just generated, we can calculate numerical summaries of the weekly number of avocados sold as a quick metric of the difference in buying patterns for conventional and organic avocados. Before we calculate these summaries, though, we should create a new column for log-10-transformed <code>total_volume</code>, as we saw earlier in our graphs that it’s massively right-tailed and needs to be log-transformed to look more normal.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># The double-sided assignment pipe %&lt;&gt;%, from magrittr</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="co"># you can use this by library()-ing magrittr</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co"># in addition to library(tidyverse)</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co"># avocado %&lt;&gt;% ... does the same thing as:</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="co"># avocado &lt;- avocado %&gt;% ...</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co"># so it gives us a shortcut to pipe an object into some calls,</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="co"># and then re-save the new result back into the old variable name</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="co"># let's save total_volume_log10 into avocado because we'll need it</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="co"># many times in the future</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>avocado <span class="sc">%&lt;&gt;%</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">total_volume_log10 =</span> <span class="fu">log10</span>(total_volume))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>avocado <span class="sc">%&gt;%</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(region, type) <span class="sc">%&gt;%</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarize</span>(<span class="at">mean_total_volume =</span> <span class="fu">mean</span>(total_volume_log10),</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>            <span class="at">sd_total_volume =</span> <span class="fu">sd</span>(total_volume_log10))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>`summarise()` has grouped output by 'region'. You can override using the
`.groups` argument.</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 92 × 4
# Groups:   region [46]
   region              type         mean_total_volume sd_total_volume
   &lt;chr&gt;               &lt;chr&gt;                    &lt;dbl&gt;           &lt;dbl&gt;
 1 Albany              conventional              4.95          0.140 
 2 Albany              organic                   3.29          0.205 
 3 Atlanta             conventional              5.70          0.0899
 4 Atlanta             organic                   4.00          0.236 
 5 BaltimoreWashington conventional              5.88          0.0722
 6 BaltimoreWashington organic                   4.31          0.225 
 7 Boise               conventional              4.91          0.0987
 8 Boise               organic                   3.34          0.209 
 9 Boston              conventional              5.74          0.0811
10 Boston              organic                   4.03          0.359 
# ℹ 82 more rows</code></pre>
</div>
</div>
<p>Above, we <code>group_by()</code> both <code>region</code> and <code>type</code> to get two separate means and SDs of weekly avocados sold in each region, one value each for conventional and organic avocados.</p>
<p>We can <code>pivot_wider()</code> our observation-level data, to get <code>total_volume</code> into two columns, one for the conventional avocados and one for the organic avocados, for each week. Thus, instead of two rows per week per metro region, one for each avocado type, we’ll have one row per week per metro region, with the relevant values for each avocado type in their own columns.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>avocado <span class="sc">%&gt;%</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Here, selecting the id_cols and the ONE values_from column I want to pivot out</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(year, date, region, type, total_volume_log10) <span class="sc">%&gt;%</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pivot_wider</span>(<span class="at">names_from =</span> type,</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>              <span class="at">values_from =</span> total_volume_log10,</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>              <span class="at">names_prefix =</span> <span class="st">"total_volume_"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 7,774 × 5
    year date       region total_volume_conventional total_volume_organic
   &lt;int&gt; &lt;date&gt;     &lt;chr&gt;                      &lt;dbl&gt;                &lt;dbl&gt;
 1  2015 2015-12-27 Albany                      4.81                 3.00
 2  2015 2015-12-20 Albany                      4.74                 3.07
 3  2015 2015-12-13 Albany                      5.07                 3.00
 4  2015 2015-12-06 Albany                      4.90                 3.06
 5  2015 2015-11-29 Albany                      4.71                 2.92
 6  2015 2015-11-22 Albany                      4.75                 2.93
 7  2015 2015-11-15 Albany                      4.92                 3.08
 8  2015 2015-11-08 Albany                      5.04                 3.12
 9  2015 2015-11-01 Albany                      5.00                 3.01
10  2015 2015-10-25 Albany                      4.87                 3.07
# ℹ 7,764 more rows</code></pre>
</div>
</div>
<blockquote class="blockquote">
<p><strong>Instructor’s note:</strong> Above, I’ve <code>select()</code>-ed to remove all the other outcome columns other than <code>total_volume</code> before pivoting my dataframe. If you wanted to pivot <em>all</em> outcome columns in the data by <code>type</code>, you could, as of <code>tidyr &gt;=1.0.0</code>. The least verbose way to do this would be to feed a negative column name vector into the <code>values_from</code> argument to exclude ID columns from the set of columns to pivot, like so:</p>
</blockquote>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>avocado <span class="sc">%&gt;%</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pivot_wider</span>(<span class="at">names_from =</span> type, <span class="at">values_from =</span> <span class="sc">-</span><span class="fu">c</span>(year, date, region))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 7,774 × 11
   date        year region avg_price_conventional avg_price_organic
   &lt;date&gt;     &lt;int&gt; &lt;chr&gt;                   &lt;dbl&gt;             &lt;dbl&gt;
 1 2015-12-27  2015 Albany                   1.33              1.83
 2 2015-12-20  2015 Albany                   1.35              1.89
 3 2015-12-13  2015 Albany                   0.93              1.85
 4 2015-12-06  2015 Albany                   1.08              1.84
 5 2015-11-29  2015 Albany                   1.28              1.94
 6 2015-11-22  2015 Albany                   1.26              1.94
 7 2015-11-15  2015 Albany                   0.99              1.89
 8 2015-11-08  2015 Albany                   0.98              1.88
 9 2015-11-01  2015 Albany                   1.02              1.88
10 2015-10-25  2015 Albany                   1.07              1.83
# ℹ 7,764 more rows
# ℹ 6 more variables: total_volume_conventional &lt;dbl&gt;,
#   total_volume_organic &lt;dbl&gt;, type_conventional &lt;chr&gt;, type_organic &lt;chr&gt;,
#   total_volume_log10_conventional &lt;dbl&gt;, total_volume_log10_organic &lt;dbl&gt;</code></pre>
</div>
</div>
<blockquote class="blockquote">
<p>Then, by default, since there are multiple <code>values_from</code> columns, each of them has the relevant level of <code>names_from</code> (here, avocado <code>type</code>) appended to the end of the column name with the <code>names_sep</code> separator.</p>
</blockquote>
<p>Once the data is pivoted, we can now use <code>mutate()</code> to subtract the organic total dollars spent from the conventional total dollars spent. Then, we can generate similar mean/SD summaries as we did before. Finally, we can make the little tibble print preview a bit more informative by using <code>arrange()</code> to sort the data such that the metro areas with highest conventional - organic sales volume differences get sorted to the top of the tibble.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>avocado <span class="sc">%&gt;%</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(year, date, region, type, total_volume_log10) <span class="sc">%&gt;%</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pivot_wider</span>(<span class="at">names_from =</span> type,</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>              <span class="at">values_from =</span> total_volume_log10,</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>              <span class="at">names_prefix =</span> <span class="st">"total_volume_"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">total_volume_diff =</span> total_volume_conventional <span class="sc">-</span> total_volume_organic) <span class="sc">%&gt;%</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(region) <span class="sc">%&gt;%</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarize</span>(<span class="at">mean_volume_diff =</span> <span class="fu">mean</span>(total_volume_diff),</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>            <span class="at">sd_volume_diff =</span> <span class="fu">sd</span>(total_volume_diff)) <span class="sc">%&gt;%</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">arrange</span>(<span class="fu">desc</span>(mean_volume_diff))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 46 × 3
   region            mean_volume_diff sd_volume_diff
   &lt;chr&gt;                        &lt;dbl&gt;          &lt;dbl&gt;
 1 MiamiFtLauderdale             2.25          0.285
 2 Tampa                         2.01          0.228
 3 PhoenixTucson                 1.99          0.134
 4 NewOrleansMobile              1.91          0.247
 5 GrandRapids                   1.84          0.390
 6 Orlando                       1.84          0.170
 7 DallasFtWorth                 1.80          0.177
 8 Houston                       1.76          0.235
 9 Sacramento                    1.76          0.149
10 Jacksonville                  1.74          0.171
# ℹ 36 more rows</code></pre>
</div>
</div>
<p>Huh, cities in Florida appear to be over-represented in the top several metro areas in buying more conventional than organic avocados. I wonder what’s going on there? We can’t rule out that this is driven by Florida having waaaay cheaper conventional avocados, and relatively more expensive organic avocados, which could be driving Floridian shoppers to choose conventional. We probably want to take this into account in later analyses, so that any effects of conventional vs.&nbsp;organic we see on the volume of avocados sold aren’t driven by a huge price premium for organic avocados. <a href="#hella-models">(Stay tuned!)</a></p>
<p>We can get a fair amount of mileage out of these initial visualizations and summaries, and there’s nothing wrong with using these summaries as a first pass. I do so all the time! However, when you <em>want</em> (or need) to be able to calculate more complex statistics on the weekly data for each metro area, you’ll need more complex tools.</p>
</section>
</section>
<section id="nesting-the-data" class="level2">
<h2 class="anchored" data-anchor-id="nesting-the-data">Nesting the data</h2>
<p>Nearly all of the tidyverse features we’ll be working through in the rest of this tutorial rely on two key features of R to make their magic happen: <strong>list-columns</strong> and <strong>flexible vectorizing functions.</strong></p>
<section id="intro-to-nest-unnest-and-tibble-list-columns" class="level3">
<h3 class="anchored" data-anchor-id="intro-to-nest-unnest-and-tibble-list-columns">Intro to nest(), unnest(), and tibble list-columns</h3>
<p>A df is composed of columns, each of which is a vector of identical length. But nobody ever said the columns of a df all have to be atomic vectors! <strong>A df column can be a list vector,</strong> where each element of said list-column can contain objects of different data types and lengths. While each element of list-column <em>can</em> contain objects of various and sundry types/lengths, list-columns gain a lot of power when they contain objects of <em>consistent</em> type. (When this is true, you can apply a single function to every row of a list-column, and get a single column of consistent output–this is where we’re headed.)</p>
<p>In this way, a list-column allows you to store multiple observations per unit wrapped up in such a way that the main df still has one row per unit, but you retain the observation-level data because you haven’t actually collapsed across any variables.</p>
<p>First, we’ll create a new variable by folding our observation-level data into a new shape, using <code>nest()</code> from the <code>tidyr</code> package. This is going to package the long-form avocado data into <em>nested</em> form, which is somewhere between long data (one row per observation) and wide data (one row per grouping unit).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>avo_by_region <span class="ot">&lt;-</span> avocado <span class="sc">%&gt;%</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">nest</span>(<span class="at">sales =</span> <span class="sc">-</span>region)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>A nested dataframe like the one we just created has two main column types: key columns and list-columns of sub-dataframes.</p>
<p>Key columns are the columns you might <code>group_by()</code> before, say, generating summary statistics with <code>summarize()</code>. They act as a label for the data contained in that row’s list-columns. List-columns do not contain a single atomic element in each row, but instead _a whole sub-data frame containing all the observation-level data corresponding to that key level.</p>
<blockquote class="blockquote">
<p><strong>Instructor’s note:</strong> A deeper exploration of the uses for and behaviors of list-columns is beyond the scope of the current tutorial. This tutorial assumes learners have never intentionally worked with non-dataframe list objects, and demonstrates only the case of list-columns containing data nested from an original “normal” dataframe. <a href="https://r4ds.had.co.nz/many-models.html#list-columns-1">R for Data Science’s section on dataframe list-columns</a> is a useful reference for more information on list-columns.</p>
</blockquote>
<p>Now, for list-columns, instead of actually printing the content of the vector, tibble output gives us a blurb about the object contained inside of each list element.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>avo_by_region</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 46 × 2
   region              sales             
   &lt;chr&gt;               &lt;list&gt;            
 1 Albany              &lt;tibble [338 × 6]&gt;
 2 Atlanta             &lt;tibble [338 × 6]&gt;
 3 BaltimoreWashington &lt;tibble [338 × 6]&gt;
 4 Boise               &lt;tibble [338 × 6]&gt;
 5 Boston              &lt;tibble [338 × 6]&gt;
 6 BuffaloRochester    &lt;tibble [338 × 6]&gt;
 7 Charlotte           &lt;tibble [338 × 6]&gt;
 8 Chicago             &lt;tibble [338 × 6]&gt;
 9 CincinnatiDayton    &lt;tibble [338 × 6]&gt;
10 Columbus            &lt;tibble [338 × 6]&gt;
# ℹ 36 more rows</code></pre>
</div>
</div>
<p>We can see here that each row of <code>sales</code>, the list-column generated by nesting the data, contains a sub-tibble with 338 rows of the other 6 columns of data corresponding to each level of <code>region</code>. The data is still there, safe and sound!</p>
<p><code>nest()</code> creates list-columns with the general argument format <code>list_col = cols_to_put_into_list_col</code>. Importantly, the columns you wish to put into the list-column can be specified using <code>select()</code> syntax. We can harness this to use the <code>-</code> to <em>exclude</em> specific key columns, and put <em>all other non-key columns into the list-column.</em> For example, if you wanted to hold out multiple key columns, for example, both <code>region</code> and <code>type</code> to split up the sub-data by conventional and organic:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>avocado <span class="sc">%&gt;%</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">nest</span>(<span class="at">sales =</span> <span class="sc">-</span><span class="fu">c</span>(region, type))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 92 × 3
   type         region              sales             
   &lt;chr&gt;        &lt;chr&gt;               &lt;list&gt;            
 1 conventional Albany              &lt;tibble [169 × 5]&gt;
 2 conventional Atlanta             &lt;tibble [169 × 5]&gt;
 3 conventional BaltimoreWashington &lt;tibble [169 × 5]&gt;
 4 conventional Boise               &lt;tibble [169 × 5]&gt;
 5 conventional Boston              &lt;tibble [169 × 5]&gt;
 6 conventional BuffaloRochester    &lt;tibble [169 × 5]&gt;
 7 conventional Charlotte           &lt;tibble [169 × 5]&gt;
 8 conventional Chicago             &lt;tibble [169 × 5]&gt;
 9 conventional CincinnatiDayton    &lt;tibble [169 × 5]&gt;
10 conventional Columbus            &lt;tibble [169 × 5]&gt;
# ℹ 82 more rows</code></pre>
</div>
</div>
<p>In this way, you can flexibly choose which columns of data to fold into your list-column, and which key-columns you want to fold by.</p>
<p>When you want to unnest the data and go back to original long form, you might not be surprised to hear that the function we’ll need is <code>unnest()</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>avo_by_region <span class="sc">%&gt;%</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">unnest</span>(sales)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 15,545 × 7
   region date       avg_price total_volume type         year total_volume_log10
   &lt;chr&gt;  &lt;date&gt;         &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt;       &lt;int&gt;              &lt;dbl&gt;
 1 Albany 2015-12-27      1.33       64237. convention…  2015               4.81
 2 Albany 2015-12-20      1.35       54877. convention…  2015               4.74
 3 Albany 2015-12-13      0.93      118220. convention…  2015               5.07
 4 Albany 2015-12-06      1.08       78992. convention…  2015               4.90
 5 Albany 2015-11-29      1.28       51040. convention…  2015               4.71
 6 Albany 2015-11-22      1.26       55980. convention…  2015               4.75
 7 Albany 2015-11-15      0.99       83454. convention…  2015               4.92
 8 Albany 2015-11-08      0.98      109428. convention…  2015               5.04
 9 Albany 2015-11-01      1.02       99811. convention…  2015               5.00
10 Albany 2015-10-25      1.07       74339. convention…  2015               4.87
# ℹ 15,535 more rows</code></pre>
</div>
</div>
<p><code>unnest()</code> takes as its argument the list-column you wish to unnest, and then thy will be done, it takes the data back into long form for you. Notice that the key column, in this case <code>region</code>, is now once again repeated for every row in the data belonging to that key level.</p>
<p>To inspect the contents of a single element of a list-column, we have to index <em>into</em> the list-column. The tidyverse function to index single columns, equivalent to dollar-sign <code>$</code> indexing dataframe columns in base R, is <code>pull()</code>. <code>pull()</code> is pipe-safe, meaning it takes a tibble/dataframe as its first argument, so we can pipe said dataframe into the function. Then, the second argument that we specify inside of the parentheses is the column name we want to index, “naked”, without quotation marks, as with other tidyverse functions.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>avo_by_region <span class="sc">%&gt;%</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pull</span>(region)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] "Albany"              "Atlanta"             "BaltimoreWashington"
 [4] "Boise"               "Boston"              "BuffaloRochester"   
 [7] "Charlotte"           "Chicago"             "CincinnatiDayton"   
[10] "Columbus"            "DallasFtWorth"       "Denver"             
[13] "Detroit"             "GrandRapids"         "GreatLakes"         
[16] "HarrisburgScranton"  "HartfordSpringfield" "Houston"            
[19] "Indianapolis"        "Jacksonville"        "LasVegas"           
[22] "LosAngeles"          "Louisville"          "MiamiFtLauderdale"  
[25] "Nashville"           "NewOrleansMobile"    "NewYork"            
[28] "NorthernNewEngland"  "Orlando"             "Philadelphia"       
[31] "PhoenixTucson"       "Pittsburgh"          "Portland"           
[34] "RaleighGreensboro"   "RichmondNorfolk"     "Roanoke"            
[37] "Sacramento"          "SanDiego"            "SanFrancisco"       
[40] "Seattle"             "SouthCarolina"       "Spokane"            
[43] "StLouis"             "Syracuse"            "Tampa"              
[46] "WestTexNewMexico"   </code></pre>
</div>
</div>
<p>We can see below that base R <code>$</code> indexing yields the same result:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>avo_by_region<span class="sc">$</span>region</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] "Albany"              "Atlanta"             "BaltimoreWashington"
 [4] "Boise"               "Boston"              "BuffaloRochester"   
 [7] "Charlotte"           "Chicago"             "CincinnatiDayton"   
[10] "Columbus"            "DallasFtWorth"       "Denver"             
[13] "Detroit"             "GrandRapids"         "GreatLakes"         
[16] "HarrisburgScranton"  "HartfordSpringfield" "Houston"            
[19] "Indianapolis"        "Jacksonville"        "LasVegas"           
[22] "LosAngeles"          "Louisville"          "MiamiFtLauderdale"  
[25] "Nashville"           "NewOrleansMobile"    "NewYork"            
[28] "NorthernNewEngland"  "Orlando"             "Philadelphia"       
[31] "PhoenixTucson"       "Pittsburgh"          "Portland"           
[34] "RaleighGreensboro"   "RichmondNorfolk"     "Roanoke"            
[37] "Sacramento"          "SanDiego"            "SanFrancisco"       
[40] "Seattle"             "SouthCarolina"       "Spokane"            
[43] "StLouis"             "Syracuse"            "Tampa"              
[46] "WestTexNewMexico"   </code></pre>
</div>
</div>
<p>There are definitely still instances where <code>$</code> indexing columns is the cleanest way to index. However, in this tutorial we’ll be using pipe-safe tidyverse indexing functions moving forward so that we can stick with the <code>%&gt;%</code> pipe for consistency.</p>
<p>Once we’ve used <code>pull()</code> to index a single column, we can use another tidyverse pipe-safe helper function, <code>pluck()</code>, this time for indexing elements of a vector. As a rule of thumb, <code>pull()</code> does what <code>$</code> indexing does, and <code>pluck()</code> does what <code>[]</code> indexing does. Thus, the below code indexes the <code>sales</code> column, and then specifically the first element in that column vector.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>avo_by_region <span class="sc">%&gt;%</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pull</span>(sales) <span class="sc">%&gt;%</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pluck</span>(<span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 338 × 6
   date       avg_price total_volume type          year total_volume_log10
   &lt;date&gt;         &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt;        &lt;int&gt;              &lt;dbl&gt;
 1 2015-12-27      1.33       64237. conventional  2015               4.81
 2 2015-12-20      1.35       54877. conventional  2015               4.74
 3 2015-12-13      0.93      118220. conventional  2015               5.07
 4 2015-12-06      1.08       78992. conventional  2015               4.90
 5 2015-11-29      1.28       51040. conventional  2015               4.71
 6 2015-11-22      1.26       55980. conventional  2015               4.75
 7 2015-11-15      0.99       83454. conventional  2015               4.92
 8 2015-11-08      0.98      109428. conventional  2015               5.04
 9 2015-11-01      1.02       99811. conventional  2015               5.00
10 2015-10-25      1.07       74339. conventional  2015               4.87
# ℹ 328 more rows</code></pre>
</div>
</div>
<p>We can also use the <code>dplyr</code> tools we already know to subset <code>avo_by_region()</code> to <code>pluck()</code> the data belonging to a particular region.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>avo_by_region <span class="sc">%&gt;%</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># This should give us a one-row dataframe</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># so we know the first element is the one we want</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(region <span class="sc">==</span> <span class="st">"NewYork"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pull</span>(sales) <span class="sc">%&gt;%</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pluck</span>(<span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 338 × 6
   date       avg_price total_volume type          year total_volume_log10
   &lt;date&gt;         &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt;        &lt;int&gt;              &lt;dbl&gt;
 1 2015-12-27      1.17     1129876. conventional  2015               6.05
 2 2015-12-20      1.23     1139348. conventional  2015               6.06
 3 2015-12-13      1.12     1254805. conventional  2015               6.10
 4 2015-12-06      1.2      1068972. conventional  2015               6.03
 5 2015-11-29      1.16      999170. conventional  2015               6.00
 6 2015-11-22      1.14     1111803. conventional  2015               6.05
 7 2015-11-15      1.04     1357393. conventional  2015               6.13
 8 2015-11-08      1.13     1406262. conventional  2015               6.15
 9 2015-11-01      1.06     2180520. conventional  2015               6.34
10 2015-10-25      1.23     1048046. conventional  2015               6.02
# ℹ 328 more rows</code></pre>
</div>
</div>
<p>Notice that once you’ve got only one row in a nested dataframe, <code>pluck()</code>-ing to unlist the data in the list-column is equivalent to using <code>unnest()</code> to unfold all rows of the list-column.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>avo_by_region <span class="sc">%&gt;%</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(region <span class="sc">==</span> <span class="st">"NewYork"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">unnest</span>(sales)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 338 × 7
   region  date       avg_price total_volume type        year total_volume_log10
   &lt;chr&gt;   &lt;date&gt;         &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt;      &lt;int&gt;              &lt;dbl&gt;
 1 NewYork 2015-12-27      1.17     1129876. conventio…  2015               6.05
 2 NewYork 2015-12-20      1.23     1139348. conventio…  2015               6.06
 3 NewYork 2015-12-13      1.12     1254805. conventio…  2015               6.10
 4 NewYork 2015-12-06      1.2      1068972. conventio…  2015               6.03
 5 NewYork 2015-11-29      1.16      999170. conventio…  2015               6.00
 6 NewYork 2015-11-22      1.14     1111803. conventio…  2015               6.05
 7 NewYork 2015-11-15      1.04     1357393. conventio…  2015               6.13
 8 NewYork 2015-11-08      1.13     1406262. conventio…  2015               6.15
 9 NewYork 2015-11-01      1.06     2180520. conventio…  2015               6.34
10 NewYork 2015-10-25      1.23     1048046. conventio…  2015               6.02
# ℹ 328 more rows</code></pre>
</div>
</div>
<blockquote class="blockquote">
<p><strong>Instructor’s note:</strong> To use exclusively base R to index into list-columns, you have to be careful when you want to use single-bracket indexing (e.g.&nbsp;to conditional-index based in values in another column of the df) versus double-bracket indexing (to actually expose the value of the list-column for printing to console or otherwise manipulation). For a more in-depth exploration of base R indexing into lists, please visit the <a href="https://r4ds.had.co.nz/vectors.html#lists">relevant R for Data Science chapter</a>.</p>
</blockquote>
</section>
</section>
<section id="going-vectorize-crazy" class="level2">
<h2 class="anchored" data-anchor-id="going-vectorize-crazy">Going vectorize crazy</h2>
<p>Next, we’ll review vectorizing: this is a feature of R that you probably use all the time and don’t even know it! We’ll learn a little more about what vectorized functions do and how you can vectorize any function you wish.</p>
<p>To read more in-depth about vectorized functions in R, check out Noam Ross’s handy <a href="http://www.noamross.net/blog/2014/4/16/vectorization-in-r--why.html">blog post</a>. We won’t be getting deep into the nuts and bolts of how vectorization works in R today. We’ll just be discussing it at a high level that should orient you enough to be able to make quick use of vectorizing helper functions.</p>
<section id="vectorizing-its-like-a-for-loop-but-not" class="level3">
<h3 class="anchored" data-anchor-id="vectorizing-its-like-a-for-loop-but-not">Vectorizing: it’s like a for loop, but not</h3>
<p>As you’ve likely experienced, much data processing requires writing code to perform a particular action, and then wrapping it in other code to repeat that action many times over many objects. In R, this usually means doing the same operation to every element in a vector or every row in a df column.</p>
<p>In most computing languages, the most sensible way to do one thing a bunch of times is to use a for loop, which (I know you know this but I’ll spell it out just to be extra) repeats the code inside the loop once for every element of a vector that’s specified at the beginning of the loop code.</p>
<p>To use a for loop to apply some function to every element of a df column, you might write something like:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(df)) {</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>  df<span class="sc">$</span>new_col[i] <span class="ot">=</span> <span class="fu">my_function</span>(df<span class="sc">$</span>old_col[i])</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>and that would do the trick. In this case, the vector you iterate along contains the row indices of your df, which means that on every iteration of your loop you’re calling <code>my_function()</code> on the next row of data until you get to the end of your df.</p>
<p>This is a perfectly functional way to write code! Today, I’ll argue that it’s prone to typos that might cause you big headaches. Specifically, these typos may cause your code to <strong>fail silently</strong> (ominous organ riff), or do something unintended without throwing an error. This means you wouldn’t find out that something was wrong unless you visually inspected the output, which you can’t always do after every command (I getcha). Thus, there’s a risk of inducing mistakes in the data that you don’t catch until it’s too late.</p>
<p>For example, once I wrote a for loop just like the above, to perform some functions on every row of a df column, but I wrote <code>df$old_col[1]</code> instead of <code>df$old_col[i]</code>. I accidentally produced the same value in every element of <code>df$new_col</code>, because even though the for loop was iterating as usual, on every iteration of the loop it was calling the same value. I didn’t discover my typo until weeks later. No bueno!</p>
<p>Enter… vectorizing.</p>
<p>It turns out that R has built-in optimized functionality for repeating functions along every element of a vector, just waiting for you to harness!</p>
<p>Generally, any vectorized function:</p>
<ul>
<li>takes a vector as input</li>
<li>does the <em>same</em> thing to <em>every</em> element of that vector</li>
<li>returns a vector of the <em>same</em> length as output</li>
</ul>
<p>Plenty of functions are already vectorized, and you likely already use them as such, including:</p>
<ul>
<li>math operators (R assumes element-wise math as the default, and element-wise == vectorized here)
<ul>
<li>arithmetic operators: <code>+</code>, <code>-</code>, and the like</li>
<li><code>round()</code>, for example</li>
</ul></li>
<li>string manipulation functions
<ul>
<li><code>paste()</code> always returns a vector equal to the longest input vector</li>
<li>pattern matching functions like <code>grep()</code>, <code>grepl()</code>, and such</li>
</ul></li>
<li>statistical distribution functions
<ul>
<li>the <code>d*()</code>, <code>p*()</code>, and <code>q*()</code> statistical distribution functions (e.g.&nbsp;<code>qnorm()</code>) are all vectorized along their main input arguments</li>
</ul></li>
<li>other stuff too!
<ul>
<li><code>base::ifelse()</code> is vectorized, as it determines true/false for each pair of elements in the two vector arguments element-wise</li>
<li>and MANY more</li>
</ul></li>
</ul>
<p>In general, it’s worth always checking to see if the function you plan to call on a vector is vectorized, and then you can use it on your vector or dataframe column without needing any additional looping.</p>
</section>
<section id="tidy-vectorizing" class="level3">
<h3 class="anchored" data-anchor-id="tidy-vectorizing">Tidy vectorizing</h3>
<p>If you use <code>mutate()</code> for your everyday column-wise data manipulation needs, using vectorized functions is smooth. In fact, <code>mutate()</code> is built to encourage you to use vectorized functions for column manipulation.</p>
<p>If we go back to the Hass avocado sale data, we can see this at work. For example, let’s take another look at the code we used earlier to create a new column for the weekly total number of avocados sold, but log-10 transformed. Earlier, we saw order-of-magnitude differences in avocado sales between different regions, so we log-transformed the data to get it to be more normally distributed.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>avocado <span class="sc">%&gt;%</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">total_volume_log10 =</span> <span class="fu">log10</span>(total_volume)) <span class="sc">%&gt;%</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(region, date, total_volume, total_volume_log10)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 15,545 × 4
   region date       total_volume total_volume_log10
   &lt;chr&gt;  &lt;date&gt;            &lt;dbl&gt;              &lt;dbl&gt;
 1 Albany 2015-12-27       64237.               4.81
 2 Albany 2015-12-20       54877.               4.74
 3 Albany 2015-12-13      118220.               5.07
 4 Albany 2015-12-06       78992.               4.90
 5 Albany 2015-11-29       51040.               4.71
 6 Albany 2015-11-22       55980.               4.75
 7 Albany 2015-11-15       83454.               4.92
 8 Albany 2015-11-08      109428.               5.04
 9 Albany 2015-11-01       99811.               5.00
10 Albany 2015-10-25       74339.               4.87
# ℹ 15,535 more rows</code></pre>
</div>
</div>
<p>We can write this in one call, without needing to wrap it in a loop, because <code>log10()</code> is vectorized, and returns a vector the same length as the input vector. Neat! You can use any vectorized functions “naked” (without any extra looping code) to create new dataframe columns inside of <code>mutate()</code> with no problem.</p>
<p>But what about functions that aren’t already vectorized? Can we use R magic to make them vectorized, if we so wish? Why yes, we can!</p>
<section id="intro-to-map-anything-is-vectorized-if-you-want" class="level4">
<h4 class="anchored" data-anchor-id="intro-to-map-anything-is-vectorized-if-you-want">Intro to <code>map()</code>: Anything is vectorized if you want</h4>
<p>At their root, vectorizing helper functions do <em>very nearly what a for loop does,</em> but with a little more specificity in their syntax that can help protect you from tricky typos. With a vectorizing function, you still specify the two main code components that you’d specify in a for loop:</p>
<ol type="1">
<li>The vector you want to iterate along</li>
<li>The code you want to run on every element of that vector</li>
</ol>
<p>The nice thing about using a vectorizer function is that it’s <em>designed to return a vector of the same length as the input vector,</em> so it’s perfect for data manipulation on columns in a dataframe. For loops are more flexible in that they can run any code a bunch of times, and don’t necessarily need to return a vector. If your goal is to return an output vector of the same length as your input vector, then vectorizer functions can do the trick with less work!</p>
<p>The basic tidyverse vectorizer function is <code>purrr::map()</code>. (The <code>purrr</code> package is so named because its helper functions can make your code purr with contentment, hah.) It takes the two arguments you’d expect: an input vector, and the code to run on each element of the input vector.</p>
<p>The main situation where vectorizer functions come in really handy is to vectorize functions to run along every element of a non-atomic list vector. R’s default vectorized functions are all intended for atomic vectors, and not necessarily list vectors. To vectorize arguments along a list, we need a little help.</p>
<p>To illustrate this briefly, we’ll use <code>map()</code> to vectorize an operation that isn’t vectorized by default and run it on every element of a list. We can use <code>pull()</code> to index the <code>sales</code> list-column of our nested avocado data. Indexing this list-column gives us …just… a list, where each element is a dataframe. We can then use <code>map()</code> to compute a single operation for every value in the list. Here, since every element in the list is a dataframe, we can use <code>nrow()</code> to count the number of rows of every list element.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>avo_by_region <span class="sc">%&gt;%</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Here, I'm using slice() to get only the first 10 rows of the tibble</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># to shorten the eventual output. Otherwise it would output the nrows</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># for every single region in the avocado data</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">slice</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>) <span class="sc">%&gt;%</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pull</span>(sales) <span class="sc">%&gt;%</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span>(\(x) <span class="fu">nrow</span>(x))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[1]]
[1] 338

[[2]]
[1] 338

[[3]]
[1] 338

[[4]]
[1] 338

[[5]]
[1] 338

[[6]]
[1] 338

[[7]]
[1] 338

[[8]]
[1] 338

[[9]]
[1] 338

[[10]]
[1] 338</code></pre>
</div>
</div>
<p>Aha! We see the same numbers of rows per sub-dataframe that we saw earlier in R’s automatic tibble output. (Notice that this output looks a little different than a normal atomic vector, what with the <code>[[]]</code> double bracket indices and all… we’ll address this very soon.)</p>
<p><code>map()</code>, like the vast majority of tidyverse functions, is pipe-safe, so the first argument is the vector to be iterated along. (Notice that the first argument is expected to be a <em>vector,</em> not an <em>entire dataframe,</em> but otherwise pipe-safe.)</p>
<p>The second argument clearly looks like the code that you want run on each element of that vector, but the syntax is a little different than if you were to just call <code>nrow(avocado$sales[[1]])</code> or something. This particular syntax is how tidyverse functions allow you to specify functions inside other functions without confusing R about what code to run where. Let’s unpack this a little bit:</p>
<p>The code you put in the second argument is preceded with <code>\(x)</code>, <a href="https://www.jumpingrivers.com/blog/new-features-r410-pipe-anonymous-functions/">which (as of R &gt;= 4.0) is a shortcut to define an anonymous function.</a> An <a href="https://adv-r.hadley.nz/functions.html#first-class-functions">anonymous function</a> is kind of like a “naked” function, where its underlying is showing without being assigned to a function name. Because the function is defined with no name, it can’t be reused without copying and pasting the code. But the upside is that you can define a quick little function to do one small thing without needing to store it in a function name!</p>
<p>The variable <code>x</code> that you see inside of <code>nrow(x)</code> is the anonymous function argument that was previously named using <code>\(x)</code>. (If you’d done <code>\(y)</code>, the argument would need to be called <code>nrow(y)</code> instead!) In this case, the anonymous function argument is a placeholder that tells <code>map()</code> how to feed your input vector into your looping code. Whenever you see that <code>x</code> inside of <code>map()</code> code, you can refer it as “the element I’m currently working with” in your mental pseudo-code. In this case, you can interpret the <code>map()</code> call as doing the following:</p>
<ul>
<li>Take the list <code>sales</code>, which is a column in <code>avo_by_region</code></li>
<li>With every element in that list:
<ul>
<li>Calculate the number of rows of the dataframe held inside that list element</li>
</ul></li>
<li>Return another list where the nth element contains the nrows of the nth element of <code>sales</code></li>
</ul>
<p>In this way, you can see how similar the pseudo-code of <code>map()</code> is to the pseudo-code of a for loop. Not so intimidating, hopefully!</p>
<blockquote class="blockquote">
<p><strong>Instructor’s note:</strong> <a href="https://www.tidyverse.org/blog/2022/12/purrr-1-0-0/#documentation">Since December 2022, the purrr maintainers now recommend using <code>\(x)</code> anonymous function shorthand over formula syntax inside of <code>map()</code>.</a> Tilde <code>~</code> formula-style syntax still works, as does calling a bare function names as the object, but I recommend teaching anonymous function shorthand <em>only</em> for non-advanced learners. Avoiding confusion is more important than a comprehensive explanation at this level.</p>
</blockquote>
</section>
<section id="special-versions-of-map" class="level4">
<h4 class="anchored" data-anchor-id="special-versions-of-map">Special versions of <code>map()</code></h4>
<p>It’s important to remember this: <strong><code>map()</code> <em>always</em> returns a list.</strong> Even if each element of the output list contains an element of the same atomic type, and length 1, <code>map()</code> is not going to try to guess anything and turn your output into an atomic vector. The philosophy of the tidyverse is to be conservative, and avoid guessing data types of output, lest it be wrong.</p>
<p>If you, the coder, know <em>exactly</em> the data type you expect in your output vector, you can use a specialized version of <code>map()</code> that will return an atomic output vector of your desired data type, or else throw an error (at which point you would go and fix the offending code). These are all called <code>map_*()</code>, where the suffix indicates the expected data type of your output.</p>
<p>For example, in the code chunk we used earlier where we used <code>map()</code> to calculate <code>nrow()</code> for every sub-dataframe of the <code>sales</code> column of <code>avo_by_region()</code>, every single value of <code>nrow()</code> was a number. More specifically, each one was an integer (makes sense, you can only have a integer number of rows in a dataframe), so if we use <code>map_int()</code> in place of <code>map()</code>, R will automatically unwrap our output into an atomic integer vector.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>avo_by_region <span class="sc">%&gt;%</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">slice</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>) <span class="sc">%&gt;%</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pull</span>(sales) <span class="sc">%&gt;%</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map_int</span>(\(x) <span class="fu">nrow</span>(x))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] 338 338 338 338 338 338 338 338 338 338</code></pre>
</div>
</div>
<p>There’s a version of <code>map_*()</code> for every possible atomic vector data type.</p>
<p>Added benefit: these functions will also will not coerce any output data types without your knowledge. If you pick the wrong <code>map_*()</code> function for your output data type, or the code inside <code>map_*()</code> doesn’t actually return the data type you thought it would, you’ll get an R error that should remind you to go back and fix the offending code.</p>
</section>
<section id="using-map-on-list-columns-inside-a-df" class="level4">
<h4 class="anchored" data-anchor-id="using-map-on-list-columns-inside-a-df">Using <code>map()</code> on list-columns inside a df</h4>
<p>Remember from before when we learned about creating nested dataframes, that nesting creates a <strong>list-column</strong> where each list element contains another, smaller dataframe pertaining to just the data from that row’s record. What if we wanted to manipulate the data contained inside each sub-dataframe? Since the column of nested data is a list, we should be able to use <code>map()</code> to operate on it.</p>
<p>Here, we’ll see how we can use <code>map()</code> to calculate subject-level summary statistics without discarding observation-level data from the dataframe.</p>
<p>First, let’s re-nest our observation-level avocado data, but this time, we’ll do it by region and by avocado type (conventional vs organic).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>avo_by_region_type <span class="ot">&lt;-</span> avocado <span class="sc">%&gt;%</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Notice the -c() select() syntax to exclude TWO key columns</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># from the list-column</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">nest</span>(<span class="at">sales =</span> <span class="sc">-</span><span class="fu">c</span>(region, type))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now, to see what the new, nested df looks like:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>avo_by_region_type</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 92 × 3
   type         region              sales             
   &lt;chr&gt;        &lt;chr&gt;               &lt;list&gt;            
 1 conventional Albany              &lt;tibble [169 × 5]&gt;
 2 conventional Atlanta             &lt;tibble [169 × 5]&gt;
 3 conventional BaltimoreWashington &lt;tibble [169 × 5]&gt;
 4 conventional Boise               &lt;tibble [169 × 5]&gt;
 5 conventional Boston              &lt;tibble [169 × 5]&gt;
 6 conventional BuffaloRochester    &lt;tibble [169 × 5]&gt;
 7 conventional Charlotte           &lt;tibble [169 × 5]&gt;
 8 conventional Chicago             &lt;tibble [169 × 5]&gt;
 9 conventional CincinnatiDayton    &lt;tibble [169 × 5]&gt;
10 conventional Columbus            &lt;tibble [169 × 5]&gt;
# ℹ 82 more rows</code></pre>
</div>
</div>
<p>And to verify that the observation-level sales data for the first region and avocado type is safe and sound in the first row of the list-column <code>sales</code>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>avo_by_region_type <span class="sc">%&gt;%</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pull</span>(sales) <span class="sc">%&gt;%</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pluck</span>(<span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 169 × 5
   date       avg_price total_volume  year total_volume_log10
   &lt;date&gt;         &lt;dbl&gt;        &lt;dbl&gt; &lt;int&gt;              &lt;dbl&gt;
 1 2015-12-27      1.33       64237.  2015               4.81
 2 2015-12-20      1.35       54877.  2015               4.74
 3 2015-12-13      0.93      118220.  2015               5.07
 4 2015-12-06      1.08       78992.  2015               4.90
 5 2015-11-29      1.28       51040.  2015               4.71
 6 2015-11-22      1.26       55980.  2015               4.75
 7 2015-11-15      0.99       83454.  2015               4.92
 8 2015-11-08      0.98      109428.  2015               5.04
 9 2015-11-01      1.02       99811.  2015               5.00
10 2015-10-25      1.07       74339.  2015               4.87
# ℹ 159 more rows</code></pre>
</div>
</div>
<p>Now, because our nested df has one row per region x type, it’s perfectly set up to contain some additional columns with summary statistics in them. We just need to be able to access the observation-level data inside of the <code>sales</code> column in order to compute these summary stats.</p>
<p>We can use <code>mutate()</code> to create a new column in our dataframe as per usual. However, this time, we’ll call <code>map()</code> <em>inside of</em> <code>mutate()</code> to create our own vectorized function that can operate on a list-column.</p>
<p>For our first summary statistic, let’s calculate the average avocado price across all weeks for each metropolitan area, separately for the two avocado types. We’ll do this by using <code>map()</code> to create a function that will call <code>mean()</code> on every element in the <code>sales</code> list-column, and we’ll wrap all of this inside <code>mutate()</code> so we can work inside of our main nested dataframe.</p>
<p>Below is the full function call, so you can see the output first:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>avo_by_region_type <span class="sc">%&gt;%</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">overall_avg_price =</span> <span class="fu">map_dbl</span>(sales, \(x) x <span class="sc">%&gt;%</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>                                       <span class="fu">pull</span>(avg_price) <span class="sc">%&gt;%</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>                                       <span class="fu">mean</span>()</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>                                     )</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>         )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 92 × 4
   type         region              sales              overall_avg_price
   &lt;chr&gt;        &lt;chr&gt;               &lt;list&gt;                         &lt;dbl&gt;
 1 conventional Albany              &lt;tibble [169 × 5]&gt;              1.35
 2 conventional Atlanta             &lt;tibble [169 × 5]&gt;              1.07
 3 conventional BaltimoreWashington &lt;tibble [169 × 5]&gt;              1.34
 4 conventional Boise               &lt;tibble [169 × 5]&gt;              1.08
 5 conventional Boston              &lt;tibble [169 × 5]&gt;              1.30
 6 conventional BuffaloRochester    &lt;tibble [169 × 5]&gt;              1.38
 7 conventional Charlotte           &lt;tibble [169 × 5]&gt;              1.28
 8 conventional Chicago             &lt;tibble [169 × 5]&gt;              1.37
 9 conventional CincinnatiDayton    &lt;tibble [169 × 5]&gt;              1.02
10 conventional Columbus            &lt;tibble [169 × 5]&gt;              1.07
# ℹ 82 more rows</code></pre>
</div>
</div>
<p>Now to unpack the pieces of this function call:</p>
<ol type="1">
<li>Inside of <code>mutate()</code>, we follow the same usual syntax of <code>new_col = function(old_col)</code>, but this time the function we call is <code>map()</code></li>
<li>The first argument of <code>map()</code> is the column whose elements we wish to iterate over, in this case <code>sales</code></li>
<li>The second argument of <code>map()</code> is what we wish to do to each element of <code>sales</code>
<ul>
<li>the function call is preceded by a tilde <code>~</code> per <code>map()</code>’s expected syntax</li>
<li>we first call <code>.x</code>, which refers to whatever’s contained in each element of <code>sales</code>. In this case, <code>.x</code> refers to a dataframe</li>
<li>we then use <code>%&gt;%</code> to pipe <code>.x</code> into the next operation we wish to use on it, <em>as you would use the pipe in normal usage outside of <code>map()</code></em></li>
<li>we pipe into <code>pull()</code> to choose only the column <code>avg_price</code> that’s <em>contained inside</em> each sub-dataframe of the <code>sales</code> list-column</li>
<li>we pipe the <code>avg_price</code> column into <code>mean()</code> to take the mean of that column</li>
</ul></li>
<li>We actually call <code>map_dbl()</code> instead of just <code>map()</code> because we expect each vector element to be a double with length 1, and so we use <code>map_dbl()</code> to safely unwrap the output vector into an atomic double vector</li>
</ol>
<p>You can use the same general strategy to calculate additional summary statistics, each with their own column created by using <code>map()</code> or one of its atomic output cousins on a list-column of dataframes.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>avo_by_region_type <span class="sc">%&gt;%</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># I'm indenting the close parentheses and such this way</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># to use the indentation levels to visually cue</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># which chunk of code lives in which level</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># because we are pretty deep here!</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">overall_avg_price =</span> <span class="fu">map_dbl</span>(sales,</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>                                     \(x) x <span class="sc">%&gt;%</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>                                       <span class="fu">pull</span>(avg_price) <span class="sc">%&gt;%</span></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>                                       <span class="fu">mean</span>()</span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>                                     ),</span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>         <span class="at">avg_total_volume =</span> <span class="fu">map_dbl</span>(sales,</span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a>                                    \(x) x <span class="sc">%&gt;%</span></span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a>                                      <span class="fu">pull</span>(total_volume) <span class="sc">%&gt;%</span></span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a>                                      <span class="fu">mean</span>()</span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a>                                    )</span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a>         )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 92 × 5
   type         region              sales    overall_avg_price avg_total_volume
   &lt;chr&gt;        &lt;chr&gt;               &lt;list&gt;               &lt;dbl&gt;            &lt;dbl&gt;
 1 conventional Albany              &lt;tibble&gt;              1.35           92903.
 2 conventional Atlanta             &lt;tibble&gt;              1.07          512789.
 3 conventional BaltimoreWashington &lt;tibble&gt;              1.34          773642.
 4 conventional Boise               &lt;tibble&gt;              1.08           82843.
 5 conventional Boston              &lt;tibble&gt;              1.30          561541.
 6 conventional BuffaloRochester    &lt;tibble&gt;              1.38          130410.
 7 conventional Charlotte           &lt;tibble&gt;              1.28          203331.
 8 conventional Chicago             &lt;tibble&gt;              1.37          759816.
 9 conventional CincinnatiDayton    &lt;tibble&gt;              1.02          247835.
10 conventional Columbus            &lt;tibble&gt;              1.07          169268.
# ℹ 82 more rows</code></pre>
</div>
</div>
<p>This will get you to roughly the same place as using <code>group_by()</code> and <code>summarize()</code> to calculate summary statistics on an unnested dataframe, and saving those summary stats into a second dataframe. The reason I like the list-column-plus-summaries setup is that I can keep all of my information in a single master dataframe and avoid proliferation of objects across my workspace. Keeping the data organized in a master dataframe also helps you avoid pitfalls like accidentally changing the order of rows in one of your dataframes with <code>arrange()</code>, then breaking an assumption in later code that’s based on the row index of a particular piece of data (that’s now pulling from different data than you thought!). If you keep your data yoked together as columns in a single dataframe, it saves you from misaligning your data with wayward row sorting.</p>
<p>Ultimately, it’s a matter of personal taste, but if you find that you like managing your observation-level data and your unit-level summary data in this way, then you can use these techniques as you like!</p>
</section>
</section>
<section id="a-caveat-when-not-to-vectorize" class="level3">
<h3 class="anchored" data-anchor-id="a-caveat-when-not-to-vectorize">A caveat: When not to vectorize</h3>
<p>Ultimately, I love vectorizing functions like <code>map()</code>–they’ve helped me keep a lot more of my data processing inside of tidyverse functions, and often saved me from copying and pasting code. There are, of course, cases when writing your code to work inside of vectorizing helpers isn’t necessarily optimal. Here are a couple that I’ve run into:</p>
<ul>
<li>If you need to recursively reference earlier vector elements while looping
<ul>
<li>Vectorizer functions run every iteration of your vectorizing loop <em>independently,</em> which means that the nth iteration cannot access the output of the (n-1)th iteration or any previous ones. If you need to be able to access previous loop content in later iterations, a for loop is the way to go.</li>
</ul></li>
<li>If you <em>really</em> need a progress bar to print to console, for iterating over <em>looooong</em> vectors
<ul>
<li>True console-based progress bars with must recursively access the console to create a progress bar that stays on one line from 0% to 100%, so they work best inside for loops</li>
<li>The good folks at RStudio who maintain <code>purrr</code> are still <a href="https://github.com/tidyverse/purrr/issues/149">working on building automatic progress bars</a> for <code>map()</code>, but as of publishing they’re not implemented</li>
<li>Check out the <a href="https://github.com/r-lib/progress"><code>progress</code></a> package, which contains helper functions that work inside for loops to make your own progress bars</li>
</ul></li>
</ul>
</section>
</section>
<section id="hella-models" class="level2">
<h2 class="anchored" data-anchor-id="hella-models">Hella models</h2>
<p>Now that we’ve demonstrated its functionality through a simpler example, we can get into the the real star of using <code>map()</code> inside <code>mutate()</code> to work with list-columns in a dataframe. If each element of a list can contain <em>any</em> R object that could otherwise be stored in its own variable, then a list should be able to hold model objects in it. And we can create each model object in that list-column of models by using <code>map()</code> to fit a model to every sub-dataframe in a list-column of dataframes. Then, if we produce a list-column where each element is a model object with the same values in it, because it’s the same model fit to different data, we can use <code>map()</code> again to extract model coefficients from each model in the list into their own list-column. In this way, we can generate more complex (and hopefully more informative) statistics about each of the grouping units in our multilevel data.</p>
<p>Let’s get back to the question driving our earlier data exploration, before we did a dive into list-columns and <code>map()</code>: <strong>Do avocado buyers prefer buying conventional or organic avocados? By how much? How do these patterns differ from region to region?</strong></p>
<p>The most obvious number that might be informative is the difference in <code>total_volume</code>, the total number of avocados sold in any given week, for <code>type == "organic"</code> vs <code>type == "conventional"</code>. If people buy more conventional avocados than organic avocados, we can assume they prefer the conventional avocados. But we know that the organic avocados are generally more expensive than conventional avocados in any given week. We can look at a plot of weekly prices, with the prices split for the two avocado types, to see that the price line for organic avocados is almost always more expensive.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>avocado <span class="sc">%&gt;%</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> date, <span class="at">y =</span> avg_price, <span class="at">color =</span> type)) <span class="sc">+</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>() <span class="sc">+</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_color_manual</span>(<span class="at">values =</span> avo_colors) <span class="sc">+</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_wrap</span>(<span class="sc">~</span> region) <span class="sc">+</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">y =</span> <span class="st">"Average price (dollars per avocado)"</span>,</span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>       <span class="at">title =</span> <span class="st">"Weekly prices per avocado, by organic vs. conventional"</span>) <span class="sc">+</span></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/avo-price-timeseries-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Grocery shoppers might be less likely to buy as many conventional avocados at all just because of the price. How can we take into account that organic avocados are more expensive when estimating the difference in volume of avocados purchased, to make our analysis more robust?</p>
<p>If we can adjust for the usual premium price on organic avocados, we can estimate the difference in total volume of avocados purchased, over and above that which you would expect when one type of avocado is cheaper. That might be able to tell us something like the following: <strong>if conventional and organic avocados were the same price, what is the estimated difference in volume of avocados purchased?</strong></p>
<p>This sounds like a job for <strong>linear regression!</strong></p>
<p>In the most basic case, we might consider doing a paired t-test between the weekly volume of conventional vs.&nbsp;organic avocados sold, and that could tell us whether those weekly volumes are “different”, but this t-test would be less informative than an equivalent linear regression (which estimates the same difference). Further, the linear regression allows us to create a multiple regression that lets us estimate that difference in volume of avocados sold, but adjusted for another variable–in this case, the average avocado price.</p>
<p>The model formula would look something like this:</p>
<p><code>total_volume ~ type + avg_price</code></p>
<p>We’ll want to use <code>lm()</code> to fit this model to each <code>region</code> separately, so that we can see the variation in avocado buying preference across each metropolitan area. An incidental benefit of running a multiple regression that adjusts for <code>avg_price</code> is that it helps adjust for differences in avocado prices across regions that are likely due to differences in cost of living from place to place.</p>
<section id="fitting-many-models" class="level3">
<h3 class="anchored" data-anchor-id="fitting-many-models">Fitting many models</h3>
<p>We can use dataframe list-columns, manipulated with <code>map()</code> inside <code>mutate()</code>, to fit this particular model to the avocado sales data from every metropolitan area. Since <code>mutate()</code> is amenable to defining a flexible number of columns, we can first do some light data preprocessing on the observation-level data contained in the <code>sales</code> column, and then in the next command, within <code>mutate()</code>, create a new list-column using <code>map()</code> to fit an <code>lm()</code> model to each row’s data in <code>sales</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Again, the double-sided pipe in magrittr</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="co"># to overwrite the old value of avo_by_region with the new value</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="co"># with all the new columns in it</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>avo_by_region <span class="sc">%&lt;&gt;%</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">sales =</span> <span class="fu">map</span>(sales,</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>                     <span class="co"># Yes that's right folks, we are about to use</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>                     <span class="co"># mutate() inside map() inside mutate()</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>                     \(x) x <span class="sc">%&gt;%</span></span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>                       <span class="co"># Here, let's roughly re-center avg_price</span></span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>                       <span class="co"># so the "baseline", or 0 point, is set at $1.00/avocado</span></span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a>                       <span class="co"># we already calculate total_volume_log10 earlier</span></span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a>                       <span class="co"># so we should be good there</span></span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a>                       <span class="fu">mutate</span>(<span class="at">avg_price_shift1 =</span> avg_price <span class="sc">-</span> <span class="dv">1</span>)</span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a>                     ),</span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true" tabindex="-1"></a>         <span class="co"># Now that we've preprocesed our columns</span></span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true" tabindex="-1"></a>         <span class="co"># we can fit our multiple regression</span></span>
<span id="cb57-17"><a href="#cb57-17" aria-hidden="true" tabindex="-1"></a>         <span class="co"># using lm() inside of map()</span></span>
<span id="cb57-18"><a href="#cb57-18" aria-hidden="true" tabindex="-1"></a>         <span class="at">model =</span> <span class="fu">map</span>(sales,</span>
<span id="cb57-19"><a href="#cb57-19" aria-hidden="true" tabindex="-1"></a>                     \(x) <span class="fu">lm</span>(total_volume_log10 <span class="sc">~</span> type <span class="sc">+</span> avg_price_shift1, <span class="at">data =</span> x)</span>
<span id="cb57-20"><a href="#cb57-20" aria-hidden="true" tabindex="-1"></a>                     )</span>
<span id="cb57-21"><a href="#cb57-21" aria-hidden="true" tabindex="-1"></a>         )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<blockquote class="blockquote">
<p><strong>Instructor’s note:</strong> You might be tempted to mean-center and perhaps z-score the <code>avg_price</code> column, so that it’s in units of standard deviations of avocado prices. However, you need to be careful <em>how your data is grouped/nested</em> when you center or z-score data, to know whether you’re centering your data <em>within</em> grouping unit or <em>across</em> grouping units. That is, are you centering/scaling by a mean/SD calculated separately for each grouping unit, or for all observations across units? In some cases, centering/scaling data within unit can be dangerous, because you might accidentally be scaling away the effect of interest. Scaling data across units retains between-unit differences of interest, so it’s fine in this case. You would need to unnest your observation-level data to make sure your operations are not implicitly grouped before doing any mean-centering/SD-scaling operations.</p>
</blockquote>
<p>Now that we’ve created the <code>model</code> column to hold each of our <code>lm</code> objects, let’s quickly see what the whole dataframe looks like:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>avo_by_region</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 46 × 3
   region              sales              model 
   &lt;chr&gt;               &lt;list&gt;             &lt;list&gt;
 1 Albany              &lt;tibble [338 × 7]&gt; &lt;lm&gt;  
 2 Atlanta             &lt;tibble [338 × 7]&gt; &lt;lm&gt;  
 3 BaltimoreWashington &lt;tibble [338 × 7]&gt; &lt;lm&gt;  
 4 Boise               &lt;tibble [338 × 7]&gt; &lt;lm&gt;  
 5 Boston              &lt;tibble [338 × 7]&gt; &lt;lm&gt;  
 6 BuffaloRochester    &lt;tibble [338 × 7]&gt; &lt;lm&gt;  
 7 Charlotte           &lt;tibble [338 × 7]&gt; &lt;lm&gt;  
 8 Chicago             &lt;tibble [338 × 7]&gt; &lt;lm&gt;  
 9 CincinnatiDayton    &lt;tibble [338 × 7]&gt; &lt;lm&gt;  
10 Columbus            &lt;tibble [338 × 7]&gt; &lt;lm&gt;  
# ℹ 36 more rows</code></pre>
</div>
</div>
<p>Aha! We see that in the list-column <code>model</code>, each of the top rows contains an <code>lm</code> object. Each of these <code>lm</code> objects individually can be operated on like any linear regression object stored in its own variable.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>avo_by_region <span class="sc">%&gt;%</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pull</span>(model) <span class="sc">%&gt;%</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pluck</span>(<span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = total_volume_log10 ~ type + avg_price_shift1, data = x)

Coefficients:
     (Intercept)       typeorganic  avg_price_shift1  
          5.0298           -1.5590           -0.2388  </code></pre>
</div>
</div>
<p>We can even <code>%&gt;%</code> this further into <code>summary()</code> to generate the whole regression output table:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>avo_by_region <span class="sc">%&gt;%</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pull</span>(model) <span class="sc">%&gt;%</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pluck</span>(<span class="dv">1</span>) <span class="sc">%&gt;%</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summary</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = total_volume_log10 ~ type + avg_price_shift1, data = x)

Residuals:
     Min       1Q   Median       3Q      Max 
-0.42005 -0.10962  0.00827  0.10662  0.51076 

Coefficients:
                 Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept)       5.02979    0.02068 243.168  &lt; 2e-16 ***
typeorganic      -1.55898    0.02687 -58.023  &lt; 2e-16 ***
avg_price_shift1 -0.23883    0.04608  -5.183 3.78e-07 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 0.1693 on 335 degrees of freedom
Multiple R-squared:  0.9605,    Adjusted R-squared:  0.9603 
F-statistic:  4077 on 2 and 335 DF,  p-value: &lt; 2.2e-16</code></pre>
</div>
</div>
<p>While this is not in spirit a multiple regression tutorial, we are doing a multiple regression, so now’s a handy time to review interpreting multiple regression coefficients:</p>
<ul>
<li><strong><code>Intercept</code></strong>: This tells us the estimated log-10-transformed volume of <em>conventional</em> avocados sold in a hypothetical week where conventional avocados cost $1.00 each
<ul>
<li>By default the <code>type</code> is dummy-coded so the baseline level is the first alphabetical level, and C comes before O, so the intercept assumes the baseline level is conventional avocados. Fine by me!</li>
<li>This is why we created <code>avg_price_shift1</code> earlier. If we hadn’t shifted the 0 point of <code>avg_price</code>, the intercept would be estimated for a week where conventional avocados cost $0.00 each. I’m assuming avocados are never free (otherwise we millenials would be able to afford mortgages), so shifting the baseline can make the regression coefficient estimates easier to interpret.</li>
</ul></li>
<li><strong><code>typeorganic</code></strong>: This tells us the estimated log-10-transformed difference in volume of avocados sold, between conventional and organic avocados, in a hypothetical week where <em>both</em> avocado types cost $1.00 each</li>
<li><strong><code>avg_price_shift1</code></strong>: This tells us the expected difference in volume of avocados sold between a week where avocados cost $1.00 each and a week where avocados are one price unit, or one dollar, more expensive ($2.00 each)</li>
</ul>
<p>Importantly, because this is a multiple regression, the <code>typeorganic</code> term tells us the estimate difference in volume of avocados sold with price “held constant”, or <em>if both conventional and organic avocados cost the same in a hypothetical week.</em> If we can estimate the difference volume sold when the two avocado types cost the same, and people are STILL buying more conventional avocados, there must be an extenuating reason why people don’t buy organic avocados even if they’re not more expensive.</p>
<p>The console output that you get from calling <code>summary()</code> on a single <code>lm</code> object is great for visual inspection, but there’s a whole lot of output here that is not the most efficient to parse programmatically with code. As such, we won’t be using <code>map()</code> inside <code>mutate()</code> to call <code>summary()</code> on every single model object in the <code>model</code> column. There are other functions we can use to give us cleaner, more ready-to-use output, that we’ll explore next.</p>
</section>
<section id="extracting-statistics-from-models" class="level3">
<h3 class="anchored" data-anchor-id="extracting-statistics-from-models">Extracting statistics from models</h3>
<p>In order to programmatically extract coefficients, standard errors, and other statistics of interest from each model object in the <code>model</code> column of <code>avo_by_region</code>, our nested avocado sale data, we are going to use the <code>tidy()</code> helper function in the <code>broom</code> R package. <code>broom</code> is designed for generating tidyverse-safe versions of statistical analysis objects to get you from models to plots &amp; interpretation with as little hacking as possible.</p>
<p>First, to demonstrate the output of <code>broom::tidy()</code>, we can call it just on the first model element of the <code>model</code> column of <code>avo_by_region</code> just as we called <code>summary()</code> on it above.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>avo_by_region <span class="sc">%&gt;%</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pull</span>(model) <span class="sc">%&gt;%</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pluck</span>(<span class="dv">1</span>) <span class="sc">%&gt;%</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># The only thing that's different is here,</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># the last command we call after we've plucked a single lm object:</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>  broom<span class="sc">::</span><span class="fu">tidy</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 3 × 5
  term             estimate std.error statistic   p.value
  &lt;chr&gt;               &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
1 (Intercept)         5.03     0.0207    243.   0        
2 typeorganic        -1.56     0.0269    -58.0  7.89e-177
3 avg_price_shift1   -0.239    0.0461     -5.18 3.78e-  7</code></pre>
</div>
</div>
<p>Note that I am using the <code>::</code> to call <code>tidy()</code> directly out of the <code>broom</code> package namespace without <code>library()</code>-ing the package. I prefer to use this syntax when I’m only using a single function from a package in a particular analysis document, to avoid loading too many function names into my session. (sometimes functions in different packages have overlapping names so you want to be careful!)</p>
<p>Calling <code>tidy()</code> on a single <code>lm</code> object gives us a tibble, with a column for each statistic of interest in the regression table, and a row for each term from the multiple regression. This has the same numbers as the core table output we got from calling <code>summary()</code> on the same object, but now with all the added benefits of a tibble. We can use <code>select()</code> to choose specific columns of statistics, <code>filter()</code> to choose specific rows corresponding to particular coefficients, <code>mutate()</code> to calculate new statistics from the ones we already have, and all that good stuff!</p>
<p>Another huge benefit of <code>tidy()</code> returning a tibble of model output for each model is that if we use <code>tidy()</code> inside <code>map()</code> inside <code>mutate()</code> to create a list-column of coefficients tibbles, we can create a list-column of tibble dataframes, which has specific tidyverse abilities.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>avo_by_region <span class="sc">%&lt;&gt;%</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">coefs =</span> <span class="fu">map</span>(model, \(x) broom<span class="sc">::</span><span class="fu">tidy</span>(x)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The biggest tidyverse ability is that the resulting <code>coefs</code> list-column of coefficients dataframes can then be pulled out into long form with <code>unnest()</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Storing this long dataframe into its own object</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a><span class="co"># so we can feed it into ggplot2 calls more quickly later!</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>avo_coefs <span class="ot">&lt;-</span> avo_by_region <span class="sc">%&gt;%</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># See the note below for why we're using select()</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># to retain only these two columns</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(region, coefs) <span class="sc">%&gt;%</span></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">unnest</span>(coefs)</span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>avo_coefs</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 138 × 6
   region              term             estimate std.error statistic   p.value
   &lt;chr&gt;               &lt;chr&gt;               &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
 1 Albany              (Intercept)         5.03     0.0207    243.   0        
 2 Albany              typeorganic        -1.56     0.0269    -58.0  7.89e-177
 3 Albany              avg_price_shift1   -0.239    0.0461     -5.18 3.78e-  7
 4 Atlanta             (Intercept)         5.72     0.0128    446.   0        
 5 Atlanta             typeorganic        -1.57     0.0243    -64.8  1.67e-191
 6 Atlanta             avg_price_shift1   -0.240    0.0305     -7.88 4.64e- 14
 7 BaltimoreWashington (Intercept)         5.94     0.0182    327.   0        
 8 BaltimoreWashington typeorganic        -1.51     0.0229    -65.9  6.99e-194
 9 BaltimoreWashington avg_price_shift1   -0.165    0.0383     -4.31 2.14e-  5
10 Boise               (Intercept)         4.93     0.0107    460.   0        
# ℹ 128 more rows</code></pre>
</div>
</div>
<p>And here we are, a long dataframe with a row for each coefficient from the multiple regression, and a chunk of rows for the coefficients from the model fit to a particular metro area. Usefully, this long dataframe can then be fed into a <code>ggplot2</code> plotting call, to visualize all the model outputs from each region together. That’s what we’ll get to next!</p>
<hr>
<p>Notice that as of <code>tidyr &gt;=1.0.0</code>, <code>unnest()</code>’s default behavior is to retain any other list-columns present in the df that aren’t getting unnested. If you unnested a list-column of dataframes that each had multiple rows, e.g.&nbsp;the <code>coefs</code> column, where each sub-dataframe has a row for each coefficient, the other list-column(s) getting retained would have their values <em>repeated</em> for each of the new rows created by unnesting the other column. Sometimes you might want that, but sometimes you might not want to increase your df’s memory footprint so much. In those cases, you should use <code>select()</code> to remove list-columns that you don’t want repeated before unnesting.</p>
<hr>
</section>
<section id="visualizing-many-statistics" class="level3">
<h3 class="anchored" data-anchor-id="visualizing-many-statistics">Visualizing many statistics</h3>
<p>Now that we have our model coefficients in a long form dataframe, with a chunk of rows for each metropolitan area, let’s plot the model estimates for each region!</p>
<p>Here, we’ll focus on plotting the values of the <code>typeorganic</code> term, as this will index each region’s relative buying preference (or anti-preference?) for organic relative to conventional avocados. This estimate will conveniently also be adjusted for average avocado price across regions, so it should <em>not</em> be affected by general differences in avocado prices (and cost of living) from region to region.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>avo_coefplot <span class="ot">&lt;-</span> avo_coefs <span class="sc">%&gt;%</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(term <span class="sc">==</span> <span class="st">"typeorganic"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Here, using fct_reorder() from the forcats pkg of the tidyverse</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># which provides a bunch of nice factor manipulating functions</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># super DUPER handy for reordering factor levels on a plot</span></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># this reorders the regions in order from highest to lowest estimate</span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> <span class="fu">fct_reorder</span>(region, <span class="fu">desc</span>(estimate)), <span class="at">y =</span> estimate)) <span class="sc">+</span></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>  <span class="co"># geom_pointrange takes x and y, like geom_point, </span></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># AND ymin/ymax (for vertical bars) or xmin/xmax (for horizontal bars) </span></span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># to plot a point/errorbar combo</span></span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_pointrange</span>(<span class="fu">aes</span>(<span class="at">ymin =</span> estimate <span class="sc">-</span> std.error,</span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a>                      <span class="at">ymax =</span> estimate <span class="sc">+</span> std.error),</span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a>                  <span class="at">width =</span> <span class="dv">0</span>) <span class="sc">+</span></span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a>  <span class="co"># let's annotate</span></span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a>  <span class="co"># to add guides to remind us how to interpret the log-10 scale</span></span>
<span id="cb69-16"><a href="#cb69-16" aria-hidden="true" tabindex="-1"></a>  <span class="co"># that stuff is brain-bendy!</span></span>
<span id="cb69-17"><a href="#cb69-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_hline</span>(<span class="at">yintercept =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">1</span>, <span class="sc">-</span><span class="dv">2</span>), <span class="at">linetype =</span> <span class="dv">3</span>) <span class="sc">+</span></span>
<span id="cb69-18"><a href="#cb69-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">annotate</span>(<span class="st">"text"</span>, <span class="at">x =</span> <span class="dv">8</span>, <span class="at">y =</span> <span class="sc">-</span><span class="fl">1.05</span>, <span class="at">hjust =</span> <span class="dv">0</span>,</span>
<span id="cb69-19"><a href="#cb69-19" aria-hidden="true" tabindex="-1"></a>           <span class="at">label =</span> <span class="st">"-1 on log10 = 10% as many"</span>, <span class="at">color =</span> <span class="st">"black"</span>) <span class="sc">+</span></span>
<span id="cb69-20"><a href="#cb69-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">annotate</span>(<span class="st">"text"</span>, <span class="at">x =</span> <span class="dv">8</span>, <span class="at">y =</span> <span class="sc">-</span><span class="fl">1.95</span>, <span class="at">hjust =</span> <span class="dv">0</span>,</span>
<span id="cb69-21"><a href="#cb69-21" aria-hidden="true" tabindex="-1"></a>           <span class="at">label =</span> <span class="st">"-2 on log10 = 1% as many"</span>, <span class="at">color =</span> <span class="st">"black"</span>) <span class="sc">+</span></span>
<span id="cb69-22"><a href="#cb69-22" aria-hidden="true" tabindex="-1"></a>  <span class="co"># since the region names are long and would otherwise overlap on the plot,</span></span>
<span id="cb69-23"><a href="#cb69-23" aria-hidden="true" tabindex="-1"></a>  <span class="co"># tilting them to 45 degrees will make them all stick off the plot on an angle</span></span>
<span id="cb69-24"><a href="#cb69-24" aria-hidden="true" tabindex="-1"></a>  <span class="co"># the new helper function guide_axis() takes care of specifics</span></span>
<span id="cb69-25"><a href="#cb69-25" aria-hidden="true" tabindex="-1"></a>  <span class="co"># when called within scale_x_discrete() as below (since we have discrete labels)</span></span>
<span id="cb69-26"><a href="#cb69-26" aria-hidden="true" tabindex="-1"></a>  <span class="co"># (as of ggplot2 v3.3.0)</span></span>
<span id="cb69-27"><a href="#cb69-27" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_x_discrete</span>(<span class="at">guide =</span> <span class="fu">guide_axis</span>(<span class="at">angle =</span> <span class="dv">45</span>)) <span class="sc">+</span></span>
<span id="cb69-28"><a href="#cb69-28" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">x =</span> <span class="st">"Metro area"</span>,</span>
<span id="cb69-29"><a href="#cb69-29" aria-hidden="true" tabindex="-1"></a>       <span class="at">y =</span> <span class="st">"Log-10 diff in volume of organic avos sold"</span>,</span>
<span id="cb69-30"><a href="#cb69-30" aria-hidden="true" tabindex="-1"></a>       <span class="at">title =</span> <span class="st">"People really do not buy organic avocados"</span>,</span>
<span id="cb69-31"><a href="#cb69-31" aria-hidden="true" tabindex="-1"></a>       <span class="at">subtitle =</span> <span class="st">"especially not people in Florida"</span>) <span class="sc">+</span></span>
<span id="cb69-32"><a href="#cb69-32" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning in geom_pointrange(aes(ymin = estimate - std.error, ymax = estimate + :
Ignoring unknown parameters: `width`</code></pre>
</div>
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>avo_coefplot</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/avo-raw-coefplot-1-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>On this plot, metro areas on the <em>left</em> of the plot are areas that buy a <em>greater</em> percentage of organic avocados relative to conventional, and metro areas on the <em>right</em> of the plot are areas that buy a <em>lower</em> percentage of avocados relative to conventional.</p>
<p>Be mindful of the log scale when reading these numbers off the plot–thinking on the log scale can be tricky! Since we’re using log-10 scaling here, a log-10 difference of -1 corresponds to a real difference of 10<sup>-1</sup>, or a 10% reduction in number. Similarly, a log-10 difference of -2 corresponds to a real difference of 10<sup>-2</sup>, or a 1% reduction in number. (A log-10 difference of -1.5 is not as intuitive, we’re all better off just calculating 10<sup>1.5</sup>)</p>
<p>So in Seattle, we estimate that when the price premium for organic avocados is taken into account, people buy approximately 10% as many organic avocados as they do conventional avocados. Meanwhile, in Miami &amp; Fort Lauderdale, we estimate that people buy less than 1% as many organic avocados as they do conventional avocados. A log-10 difference of 1 is a whole order of magnitude different in raw avocado units!</p>
<blockquote class="blockquote">
<p><strong>Instructor’s note:</strong> The following plot takes a bit of fiddling to set up, and requires chaining together many pieces of data wrangling logic. If learners have never made a model-estimate-plus-raw-data plot like this before, this may be a bit beyond scope to live-code. In that case, I recommend taking a couple minutes for learners to brainstorm possible strategies for extending the basic coefficient plot shown above, and then showing a fully rendered copy of the plot below as an example extension plot, qualitatively describing the added layers and annotations.</p>
</blockquote>
<div class="cell">
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>avo_raw_diffs <span class="ot">&lt;-</span> avocado <span class="sc">%&gt;%</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># first, prepare to calculate the raw difference in weekly volume</span></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># of organic - conventional avocados bought</span></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># (must be that direction bc conventional is baseline in the regression)</span></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(region, date, type, total_volume_log10) <span class="sc">%&gt;%</span></span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pivot_wider</span>(<span class="at">names_from =</span> type,</span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>              <span class="at">values_from =</span> total_volume_log10) <span class="sc">%&gt;%</span></span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">diff_raw =</span> organic <span class="sc">-</span> conventional) <span class="sc">%&gt;%</span></span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># WestTextNewMexico has some weeks with no organic avocado sales</span></span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># so we need to filter out some NA rows of diff_raw</span></span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(<span class="sc">!</span><span class="fu">is.na</span>(diff_raw)) <span class="sc">%&gt;%</span></span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a>  <span class="co"># for each region, calculate the mean and SE of the mean</span></span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a>  <span class="co"># of this difference</span></span>
<span id="cb72-14"><a href="#cb72-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(region) <span class="sc">%&gt;%</span></span>
<span id="cb72-15"><a href="#cb72-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarize</span>(<span class="at">diff_mean =</span> <span class="fu">mean</span>(diff_raw),</span>
<span id="cb72-16"><a href="#cb72-16" aria-hidden="true" tabindex="-1"></a>            <span class="at">diff_se =</span> <span class="fu">sd</span>(diff_raw)<span class="sc">/</span><span class="fu">sqrt</span>(<span class="fu">length</span>(diff_raw))) <span class="sc">%&gt;%</span> </span>
<span id="cb72-17"><a href="#cb72-17" aria-hidden="true" tabindex="-1"></a>  <span class="co"># in order for the plot to work</span></span>
<span id="cb72-18"><a href="#cb72-18" aria-hidden="true" tabindex="-1"></a>  <span class="co"># (for the regions to be ordered by the model estimate)</span></span>
<span id="cb72-19"><a href="#cb72-19" aria-hidden="true" tabindex="-1"></a>  <span class="co"># the model estimates need to be bound on to the raw diffs</span></span>
<span id="cb72-20"><a href="#cb72-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">left_join</span>(avo_coefs <span class="sc">%&gt;%</span> <span class="fu">filter</span>(term <span class="sc">==</span> <span class="st">"typeorganic"</span>),</span>
<span id="cb72-21"><a href="#cb72-21" aria-hidden="true" tabindex="-1"></a>            <span class="at">by =</span> <span class="st">"region"</span>)</span>
<span id="cb72-22"><a href="#cb72-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-23"><a href="#cb72-23" aria-hidden="true" tabindex="-1"></a>avo_coefplot <span class="sc">+</span></span>
<span id="cb72-24"><a href="#cb72-24" aria-hidden="true" tabindex="-1"></a>  <span class="co"># error bars and points for the raw data</span></span>
<span id="cb72-25"><a href="#cb72-25" aria-hidden="true" tabindex="-1"></a>  <span class="co"># notice that we use the data argument to feed in different data</span></span>
<span id="cb72-26"><a href="#cb72-26" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_pointrange</span>(<span class="fu">aes</span>(<span class="at">y =</span> diff_mean,</span>
<span id="cb72-27"><a href="#cb72-27" aria-hidden="true" tabindex="-1"></a>                      <span class="at">ymin =</span> diff_mean <span class="sc">-</span> diff_se,</span>
<span id="cb72-28"><a href="#cb72-28" aria-hidden="true" tabindex="-1"></a>                      <span class="at">ymax =</span> diff_mean <span class="sc">+</span> diff_se),</span>
<span id="cb72-29"><a href="#cb72-29" aria-hidden="true" tabindex="-1"></a>                  <span class="at">data =</span> avo_raw_diffs,</span>
<span id="cb72-30"><a href="#cb72-30" aria-hidden="true" tabindex="-1"></a>                  <span class="at">color =</span> <span class="st">"olivedrab4"</span>,</span>
<span id="cb72-31"><a href="#cb72-31" aria-hidden="true" tabindex="-1"></a>                  <span class="at">width =</span> <span class="dv">0</span>) <span class="sc">+</span></span>
<span id="cb72-32"><a href="#cb72-32" aria-hidden="true" tabindex="-1"></a>  <span class="co"># hand-adding a legend</span></span>
<span id="cb72-33"><a href="#cb72-33" aria-hidden="true" tabindex="-1"></a>  <span class="fu">annotate</span>(<span class="st">"text"</span>, <span class="at">x =</span> <span class="dv">45</span>, <span class="at">y =</span> <span class="sc">-</span><span class="fl">1.2</span>, <span class="at">hjust =</span> <span class="dv">1</span>,</span>
<span id="cb72-34"><a href="#cb72-34" aria-hidden="true" tabindex="-1"></a>           <span class="at">label =</span> <span class="st">"black = model-estimated"</span>, <span class="at">color =</span> <span class="st">"black"</span>) <span class="sc">+</span></span>
<span id="cb72-35"><a href="#cb72-35" aria-hidden="true" tabindex="-1"></a>  <span class="fu">annotate</span>(<span class="st">"text"</span>, <span class="at">x =</span> <span class="dv">45</span>, <span class="at">y =</span> <span class="sc">-</span><span class="fl">1.3</span>, <span class="at">hjust =</span> <span class="dv">1</span>,</span>
<span id="cb72-36"><a href="#cb72-36" aria-hidden="true" tabindex="-1"></a>           <span class="at">label =</span> <span class="st">"green = raw"</span>, <span class="at">color =</span> <span class="st">"olivedrab4"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning in geom_pointrange(aes(y = diff_mean, ymin = diff_mean - diff_se, :
Ignoring unknown parameters: `width`</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/avo-raw-coefplot-2-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>I think we’ve gotten pretty close to an answer (not THE answer, but AN answer) to our earlier research question: <strong>Do avocado buyers prefer buying conventional or organic avocados? By how much? How do these patterns differ from region to region?</strong></p>
<p>Avocado buyers across the US appear to prefer buying conventional avocados over organic avocados; that is, they buy many more conventional avocados than organic avocados in a given week. This holds even when you adjust for the fact that organic avocados are usually more expensive. The magnitude of this buying preference against organic avocados varies across the country–the Pacific Northwest appears to avoid organic avocados much less than the rest of the country, and Florida appears to avoid organic avocados much more than the rest of the country.</p>
<p>That concludes the core analysis of this tutorial! If you like, continue following along for a rapid-fire demonstration of another use case of <code>map()</code> inside <code>mutate()</code> with nested dataframes to repeat analysis across many datasets containing similarly structured data.</p>
</section>
</section>
<section id="bonus-example-bootstrapping" class="level2">
<h2 class="anchored" data-anchor-id="bonus-example-bootstrapping">Bonus example: bootstrapping</h2>
<blockquote class="blockquote">
<p><strong>Instructor’s note:</strong> This section is designed as a demonstration of features rather than a live how-to. The main body of the code-along lesson concludes after generating a summary graph of model statistics for each <code>region</code>. The lesson teaches one example case of using <code>map()</code> inside <code>mutate()</code> to fit a model to a bunch of sub-dataframes in a nested master dataframe, but there are other analysis contexts where this strategy comes in handy.</p>
</blockquote>
<p>Another situation where you might fit the same model to a bunch of different datasets is <strong>bootstrapping.</strong> When bootstrapping a statistic, you would:</p>
<ol type="1">
<li>resample your observations <em>with replacement</em> to yield a resampled dataset with the same N as your original dataset</li>
<li>do that resampling for many iterations to yield many resampled datasets</li>
<li>do your original analysis on every resampled dataset</li>
<li>extract the statistic of interest</li>
<li>use the distribution of that statistic across your bootstrapping iterations as the error distribution around the original value of the statistic calculated on the raw data</li>
</ol>
<p>Fitting many models and extracting key statistics using <code>map()</code> inside <code>mutate()</code> lends itself well to bootstrapping, which requires repeating the modeling operation of interest over many resampled datasets. If you had a nested dataframe, with a list-column of resampled datasets, you could absolutely use <code>map()</code> inside <code>mutate()</code> to fit a model to each resampled dataset, extract statistics, and get those statistics back into a long-form dataframe with a row for each bootstrap iteration, which you could then visualize with, say, a histogram or density plot to examine the distribution.</p>
<p>The one new technique I’ll demonstrate here is the <code>bootstraps</code> function from the <a href="https://tidymodels.github.io/rsample/"><code>rsample</code> package</a> in the extended tidyverse. <code>rsample</code> contains functions for sampling data for things like cross-validation and holding out testing data to test model predictions. In our case, we’ll be using a single function, <code>bootstraps()</code>, which as you might guess generates bootstrap resamples of a dataset. <code>bootstraps()</code> and other sampling functions in <code>rsample</code> have the added benefit of using special tools under the hood to reduce the size of resampled datasets in memory, which helps reduce stress on your R session.</p>
<p>In this demonstration, I’ll bootstrap the error distribution on New York’s model estimate for the avocado <code>volume ~ type + price</code> multiple regression we ran earlier. First, I’ll pull out New York’s raw data, and then feed it into <code>bootstraps()</code> to create a dataframe with a row for every bootstrap iteration, and a list-column containing that iteration’s resampled dataset.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>avo_nyc_boot <span class="ot">&lt;-</span> avo_by_region <span class="sc">%&gt;%</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(region <span class="sc">==</span> <span class="st">"NewYork"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Mustn't forget to select() only the group id column</span></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># and the list-column we wish to unnest</span></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># lest we accidentally replicate all the extra columns</span></span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># in this case, we want the column containing the RAW data</span></span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(region, sales) <span class="sc">%&gt;%</span></span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>  <span class="co"># unnesting will give us a long dataframe with just New York's weekly data</span></span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">unnest</span>(sales) <span class="sc">%&gt;%</span></span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># this WHOLE dataframe get fed in as the first argument of bootstraps</span></span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a>  <span class="co"># the times argument sets the # of bootstrap iterations</span></span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true" tabindex="-1"></a>  rsample<span class="sc">::</span><span class="fu">bootstraps</span>(<span class="at">times =</span> <span class="dv">200</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s see what the dataframe output of <code>bootstraps()</code> looks like:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb75"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>avo_nyc_boot</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># Bootstrap sampling 
# A tibble: 200 × 2
   splits            id          
   &lt;list&gt;            &lt;chr&gt;       
 1 &lt;split [338/122]&gt; Bootstrap001
 2 &lt;split [338/118]&gt; Bootstrap002
 3 &lt;split [338/122]&gt; Bootstrap003
 4 &lt;split [338/124]&gt; Bootstrap004
 5 &lt;split [338/137]&gt; Bootstrap005
 6 &lt;split [338/126]&gt; Bootstrap006
 7 &lt;split [338/126]&gt; Bootstrap007
 8 &lt;split [338/138]&gt; Bootstrap008
 9 &lt;split [338/119]&gt; Bootstrap009
10 &lt;split [338/125]&gt; Bootstrap010
# ℹ 190 more rows</code></pre>
</div>
</div>
<p><code>bootstraps()</code> returns a dataframe with a character column called <code>id</code> which labels each iteration, and a list column called <code>splits</code> where each element houses metadata for a resampled dataset. I say metadata because part of the trick that <code>bootstraps()</code> uses is that the native <code>split</code> object type doesn’t actually contain any data on its own:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb77"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>avo_nyc_boot <span class="sc">%&gt;%</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pull</span>(splits) <span class="sc">%&gt;%</span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pluck</span>(<span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;Analysis/Assess/Total&gt;
&lt;338/122/338&gt;</code></pre>
</div>
</div>
<p>These numbers aren’t really designed for human consumption on their own. The real magic happens when you call <code>as.data.frame()</code> on a <code>split</code> object, which triggers it to actually do the resampling and give you a tibble of data.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb79"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>avo_nyc_boot <span class="sc">%&gt;%</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pull</span>(splits) <span class="sc">%&gt;%</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pluck</span>(<span class="dv">1</span>) <span class="sc">%&gt;%</span></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as.data.frame</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 338 × 8
   region  date       avg_price total_volume type        year total_volume_log10
   &lt;chr&gt;   &lt;date&gt;         &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt;      &lt;int&gt;              &lt;dbl&gt;
 1 NewYork 2017-08-20      1.75     1057189. conventio…  2017               6.02
 2 NewYork 2018-03-18      1.7       189434. organic     2018               5.28
 3 NewYork 2017-05-28      2.38       76002. organic     2017               4.88
 4 NewYork 2015-08-02      2.12       13852. organic     2015               4.14
 5 NewYork 2016-08-21      2.16       30583. organic     2016               4.49
 6 NewYork 2016-09-04      1.47     1278749. conventio…  2016               6.11
 7 NewYork 2017-08-20      1.85      107275. organic     2017               5.03
 8 NewYork 2016-12-11      2.22       32659. organic     2016               4.51
 9 NewYork 2015-02-01      1.36     1433763. conventio…  2015               6.16
10 NewYork 2016-07-31      2.41       24048. organic     2016               4.38
# ℹ 328 more rows
# ℹ 1 more variable: avg_price_shift1 &lt;dbl&gt;</code></pre>
</div>
</div>
<p>To double-check that the data were actually resampled with replacement, we can look in this first resampled tibble to make sure that at least some of the rows appear multiple times in the data.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb81"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>avo_nyc_boot <span class="sc">%&gt;%</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pull</span>(splits) <span class="sc">%&gt;%</span></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pluck</span>(<span class="dv">1</span>) <span class="sc">%&gt;%</span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as.data.frame</span>() <span class="sc">%&gt;%</span></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">count</span>(date) <span class="sc">%&gt;%</span></span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">arrange</span>(<span class="fu">desc</span>(n))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 144 × 2
   date           n
   &lt;date&gt;     &lt;int&gt;
 1 2016-12-18     6
 2 2015-05-24     5
 3 2015-12-27     5
 4 2016-06-19     5
 5 2016-09-18     5
 6 2016-12-11     5
 7 2017-05-14     5
 8 2017-05-28     5
 9 2015-02-22     4
10 2015-04-19     4
# ℹ 134 more rows</code></pre>
</div>
</div>
<p>Looks resampled to me! Now, we can use the same strategy we used before, but instead of operating on the raw data for each <code>region</code> contained in the <code>sales</code> column of <code>avo_by_region</code>, we’ll operate on the resampled data for each bootstrap <code>id</code> contained in the <code>splits</code> column of <code>avo_nyc_boot</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb83"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>avo_nyc_boot <span class="sc">%&lt;&gt;%</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Note that here, I'm not saving the models into their own column</span></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># but instead piping the model result of lm()</span></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># DIRECTLY into broom::tidy() to go directly to the coefficients tibble</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">coefs_boot =</span> <span class="fu">map</span>(splits,</span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a>                          \(x) x <span class="sc">%&gt;%</span></span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a>                            <span class="co"># we need to call this first</span></span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a>                            <span class="co"># to turn the splits object into data </span></span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true" tabindex="-1"></a>                            <span class="fu">as.data.frame</span>() <span class="sc">%&gt;%</span></span>
<span id="cb83-10"><a href="#cb83-10" aria-hidden="true" tabindex="-1"></a>                            <span class="co"># now we may proceed as usual</span></span>
<span id="cb83-11"><a href="#cb83-11" aria-hidden="true" tabindex="-1"></a>                            <span class="fu">lm</span>(total_volume_log10 <span class="sc">~</span> type <span class="sc">+</span> avg_price_shift1, <span class="at">data =</span> .) <span class="sc">%&gt;%</span></span>
<span id="cb83-12"><a href="#cb83-12" aria-hidden="true" tabindex="-1"></a>                            broom<span class="sc">::</span><span class="fu">tidy</span>()</span>
<span id="cb83-13"><a href="#cb83-13" aria-hidden="true" tabindex="-1"></a>                          )</span>
<span id="cb83-14"><a href="#cb83-14" aria-hidden="true" tabindex="-1"></a>         ) <span class="sc">%&gt;%</span></span>
<span id="cb83-15"><a href="#cb83-15" aria-hidden="true" tabindex="-1"></a>  <span class="co"># again, use select to remove any columns we don't want repeated</span></span>
<span id="cb83-16"><a href="#cb83-16" aria-hidden="true" tabindex="-1"></a>  <span class="co"># when unnesting</span></span>
<span id="cb83-17"><a href="#cb83-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(<span class="sc">-</span>splits) <span class="sc">%&gt;%</span></span>
<span id="cb83-18"><a href="#cb83-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">unnest</span>(coefs_boot)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If we inspect the long-form unnested content of <code>avo_nyc_boot</code> after we’ve pulled out the bootstrapped coefficients, it looks pretty similar to the unnested coefficients in <code>avo_coefs</code>, but this time instead of coefficients by <code>region</code>, we’ve got coefficients by bootstrap <code>id</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb84"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>avo_nyc_boot</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 600 × 6
   id           term             estimate std.error statistic   p.value
   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
 1 Bootstrap001 (Intercept)         6.23     0.0285    218.   0        
 2 Bootstrap001 typeorganic        -1.41     0.0450    -31.3  2.03e-101
 3 Bootstrap001 avg_price_shift1   -0.255    0.0562     -4.54 7.99e-  6
 4 Bootstrap002 (Intercept)         6.28     0.0283    222.   0        
 5 Bootstrap002 typeorganic        -1.31     0.0441    -29.7  7.27e- 96
 6 Bootstrap002 avg_price_shift1   -0.383    0.0564     -6.78 5.51e- 11
 7 Bootstrap003 (Intercept)         6.29     0.0289    217.   0        
 8 Bootstrap003 typeorganic        -1.28     0.0409    -31.4  1.13e-101
 9 Bootstrap003 avg_price_shift1   -0.397    0.0539     -7.37 1.35e- 12
10 Bootstrap004 (Intercept)         6.24     0.0279    223.   0        
# ℹ 590 more rows</code></pre>
</div>
</div>
<p>These coefficients are now ready to feed into a <code>ggplot2</code> histogram. I’ll just inspect the bootstrapped error distribution for <code>typeorganic</code>, the coefficient for the weekly difference in (log-10) volume of organic avocados sold relative to conventional avocados.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb86"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>avo_nyc_boot <span class="sc">%&gt;%</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(term <span class="sc">==</span> <span class="st">"typeorganic"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> estimate)) <span class="sc">+</span></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_histogram</span>() <span class="sc">+</span></span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/avo-boot-hist-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>We can see that this error distribution shows high kurtosis; that is, that the tails are short and the center of distribution is thick. This means we probably don’t want to use the standard deviation of this distribution as the standard error of the estimate, since the error distribution isn’t normal. Instead, we can use percentiles to report error intervals non-parametrically.</p>
<p>For the last plot I’ll show in this demo, I’ll do a bit more data manipulation to join the bootstrapped standard error data and the “raw” <code>lm()</code>-estimated standard error data for the original New York avocado sales model, to produce a plot comparing the standard errors from the model estimate and from bootstrapping. This way we can see how much more conservative (how much larger) the bootstrapped standard error is relative to the <code>lm()</code>-estimated error.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb88"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>avo_nyc_boot <span class="sc">%&gt;%</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># for each term in the model, over all bootstrap iterations,</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(term) <span class="sc">%&gt;%</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># calculate its mean, SD,</span></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># and the 16th and 84th percentiles</span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># to correspond with estimate +- 1 SE</span></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a>  <span class="co"># bc percentiles are non-parametric</span></span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>  <span class="co"># so, safe for non-normal distribution</span></span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarize</span>(<span class="at">estimate_boot =</span> <span class="fu">mean</span>(estimate),</span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a>            <span class="at">se_boot =</span> <span class="fu">sd</span>(estimate),</span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a>            <span class="at">q16_boot =</span> <span class="fu">quantile</span>(estimate, .<span class="dv">16</span>),</span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true" tabindex="-1"></a>            <span class="at">q84_boot =</span> <span class="fu">quantile</span>(estimate, .<span class="dv">84</span>)) <span class="sc">%&gt;%</span></span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true" tabindex="-1"></a>  <span class="co"># now, horizontally join on the coefs from the raw data</span></span>
<span id="cb88-14"><a href="#cb88-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">left_join</span>(avo_coefs <span class="sc">%&gt;%</span></span>
<span id="cb88-15"><a href="#cb88-15" aria-hidden="true" tabindex="-1"></a>              <span class="fu">filter</span>(region <span class="sc">==</span> <span class="st">"NewYork"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb88-16"><a href="#cb88-16" aria-hidden="true" tabindex="-1"></a>              <span class="fu">select</span>(term, <span class="at">estimate_raw =</span> estimate, <span class="at">se_raw =</span> std.error) <span class="sc">%&gt;%</span></span>
<span id="cb88-17"><a href="#cb88-17" aria-hidden="true" tabindex="-1"></a>              <span class="co"># assuming a normal distribution,</span></span>
<span id="cb88-18"><a href="#cb88-18" aria-hidden="true" tabindex="-1"></a>              <span class="co"># rough-calculate the expected 16th and 84th percentiles</span></span>
<span id="cb88-19"><a href="#cb88-19" aria-hidden="true" tabindex="-1"></a>              <span class="co"># to go along with the values in the bootstrapped coefs</span></span>
<span id="cb88-20"><a href="#cb88-20" aria-hidden="true" tabindex="-1"></a>              <span class="fu">mutate</span>(<span class="at">q16_raw =</span> estimate_raw <span class="sc">-</span> se_raw,</span>
<span id="cb88-21"><a href="#cb88-21" aria-hidden="true" tabindex="-1"></a>                     <span class="at">q84_raw =</span> estimate_raw <span class="sc">+</span> se_raw),</span>
<span id="cb88-22"><a href="#cb88-22" aria-hidden="true" tabindex="-1"></a>            <span class="at">by =</span> <span class="st">"term"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb88-23"><a href="#cb88-23" aria-hidden="true" tabindex="-1"></a>  <span class="co"># use pivot_longer to get all the cols other than term,</span></span>
<span id="cb88-24"><a href="#cb88-24" aria-hidden="true" tabindex="-1"></a>  <span class="co"># which are duplicated for the boot and raw coefs,</span></span>
<span id="cb88-25"><a href="#cb88-25" aria-hidden="true" tabindex="-1"></a>  <span class="co"># into long form with a column indicating boot vs. raw</span></span>
<span id="cb88-26"><a href="#cb88-26" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pivot_longer</span>(<span class="at">cols =</span> <span class="sc">-</span>term,</span>
<span id="cb88-27"><a href="#cb88-27" aria-hidden="true" tabindex="-1"></a>               <span class="at">names_to =</span> <span class="fu">c</span>(<span class="st">".value"</span>, <span class="st">"model_type"</span>),</span>
<span id="cb88-28"><a href="#cb88-28" aria-hidden="true" tabindex="-1"></a>               <span class="co"># see the pivot_longer docs for more info on this argument!</span></span>
<span id="cb88-29"><a href="#cb88-29" aria-hidden="true" tabindex="-1"></a>               <span class="at">names_pattern =</span> <span class="st">"(.*)_(.*)"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb88-30"><a href="#cb88-30" aria-hidden="true" tabindex="-1"></a>  <span class="co"># again, just plotting the coefs for typeorganic</span></span>
<span id="cb88-31"><a href="#cb88-31" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(term <span class="sc">==</span> <span class="st">"typeorganic"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb88-32"><a href="#cb88-32" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> estimate, <span class="at">y =</span> model_type)) <span class="sc">+</span></span>
<span id="cb88-33"><a href="#cb88-33" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_pointrange</span>(<span class="fu">aes</span>(<span class="at">xmin =</span> q16,</span>
<span id="cb88-34"><a href="#cb88-34" aria-hidden="true" tabindex="-1"></a>                      <span class="at">xmax =</span> q84),</span>
<span id="cb88-35"><a href="#cb88-35" aria-hidden="true" tabindex="-1"></a>                  <span class="at">height =</span> <span class="dv">0</span>) <span class="sc">+</span></span>
<span id="cb88-36"><a href="#cb88-36" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">x =</span> <span class="st">"Estimate +- 1 'standard error'"</span>,</span>
<span id="cb88-37"><a href="#cb88-37" aria-hidden="true" tabindex="-1"></a>       <span class="at">y =</span> <span class="st">"error type"</span>,</span>
<span id="cb88-38"><a href="#cb88-38" aria-hidden="true" tabindex="-1"></a>       <span class="at">title =</span> <span class="st">"Bootstrap vs. 'raw' errors for the New York avocado sale volume regression"</span>,</span>
<span id="cb88-39"><a href="#cb88-39" aria-hidden="true" tabindex="-1"></a>       <span class="at">subtitle =</span> <span class="st">"The bootstrapped error is more conservative"</span>) <span class="sc">+</span></span>
<span id="cb88-40"><a href="#cb88-40" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning in geom_pointrange(aes(xmin = q16, xmax = q84), height = 0): Ignoring
unknown parameters: `height`</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/avo-boot-coefplot-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Yep, it looks like the error bounds on the bootstrapped data are wider than the equivalent standard error from the <code>lm</code> fit to the raw data. This will usually be the case! Perhaps a good argument to use bootstrapped standard errors more often, to be conservative with our statistics.</p>
</section>
</section>
<section id="in-closing" class="level1">
<h1>In closing</h1>
<p>I hope from this tutorial you’ve become comfortable exploring multilevel data by using <code>nest()</code> and <code>unnest()</code> to work with list-columns of sub-dataframes, and by using <code>map()</code> inside <code>mutate()</code> to calculate all manner of summary statistics for each grouping unit in your data. The tools and techniques we’ve practiced here may prove useful to you for all sorts of other data wrangling and sense-making tasks, so keep an eye out for contexts with similarly structured data where you might be able to use these tools.</p>
<p>Happy analyzing!</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/www\.monicathieu\.com");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>